# Created 2020-04-04 Sat 18:13
#+OPTIONS: toc:nil d:nil
#+OPTIONS: toc:nil d:nil
#+TITLE: Haskell CheatSheet
#+AUTHOR: [[https://alhassy.github.io/][Musa Al-hassy]]
#+export_file_name: README.org

A reference sheet for the basics of the mind-expanding Haskell language (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

#+begin_quote
*The listing sheet, as PDF, can be found
 [[https://alhassy.github.io/HaskellCheatSheet/CheatSheet.pdf][here]]*,
 or as a [[https://alhassy.github.io/HaskellCheatSheet/CheatSheet_Portrait.pdf][single column portrait]],
 while below is an unruly html rendition.
#+end_quote

This reference sheet is built from a
[[https://github.com/alhassy/CheatSheet][CheatSheets with Org-mode]]
system.

#+html: <p align="center"><a href="https://www.haskell.org/"><img src="https://img.shields.io/badge/GHC-8.6.4-b48ead.svg?style=plastic"/></a>

#+toc: headlines 2
#+macro: blurb A reference sheet for the basics of the mind-expanding Haskell language (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

#+latex_header: \usepackage{titling,parskip}
#+latex_header: \usepackage{eufrak} % for mathfrak fonts
#+latex_header: \usepackage{multicol,xparse,newunicodechar}

#+latex_header: \usepackage{etoolbox}

#+latex_header: \newif\iflandscape
#+latex_header: \landscapetrue

#+latex_header_extra: \iflandscape \usepackage[landscape, margin=0.5in]{geometry} \else \usepackage[margin=0.5in]{geometry} \fi

#+latex_header: \def\cheatsheetcols{2}
#+latex_header: \AfterEndPreamble{\begin{multicols}{\cheatsheetcols}}
#+latex_header: \AtEndDocument{ \end{multicols} }

#+latex_header: \let\multicolmulticols\multicols
#+latex_header: \let\endmulticolmulticols\endmulticols
#+latex_header: \RenewDocumentEnvironment{multicols}{mO{}}{\ifnum#1=1 #2 \def\columnbreak{} \else \multicolmulticols{#1}[#2] \fi}{\ifnum#1=1 \else \endmulticolmulticols\fi}

#+latex_header: \def\maketitle{}
#+latex: \fontsize{9}{10}\selectfont

#+latex_header: \def\cheatsheeturl{}

#+latex_header: \usepackage[dvipsnames]{xcolor} % named colours
#+latex: \definecolor{grey}{rgb}{0.5,0.5,0.5}

#+latex_header: \usepackage{color}
#+latex_header: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
#+latex_header: \definecolor{darkblue}{rgb}{0.0, 0.1, 0.3}
#+latex_header: \hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkgreen}

#+latex_header: \setlength{\parindent}{0pt}


#+latex_header: \def\cheatsheetitemsep{-0.5em}
#+latex_header: \let\olditem\item
#+latex_header_extra: \def\item{\vspace{\cheatsheetitemsep}\olditem}

#+latex_header: \usepackage{CheatSheet/UnicodeSymbols}

#+latex_header: \makeatletter
#+latex_header: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+latex_header: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+latex_header: \makeatother



#+latex_header: \RequirePackage{fancyvrb}
#+latex_header: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}


#+macro: newline @@latex: \newline@@

#+latex_header: \def\cheatsheeturl{https://github.com/alhassy/HaskellCheatSheet}

#+latex_header: \def\cheatsheetcols{2}
#+latex_header: \landscapetrue
#+latex_header: \def\cheatsheetitemsep{-0.5em}

#+latex_header: \newunicodechar{ùëª}{\ensuremath{T}}
#+latex_header: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+latex_header: \newunicodechar{‚âà}{\ensuremath{\approx}}
#+latex_header: \newunicodechar{ùìç}{\ensuremath{x}}
#+latex_header: \newunicodechar{Œ±}{\ensuremath{\alpha}}
#+latex_header: \newunicodechar{Œ≤}{\ensuremath{\beta}}
#+latex_header: \newunicodechar{Œµ}{\ensuremath{\epsilon}}
#+latex_header: \newunicodechar{‚àÇ}{\ensuremath{\partial}}
#+latex_header: \newunicodechar{‚äù}{\ensuremath{\ominus}}
#+latex_header: \newunicodechar{‚Çã}{\ensuremath{_-}}
#+latex_header: \newunicodechar{‚ü∂}{\ensuremath{\rightarrow}}
#+latex_header: \newunicodechar{‚àâ}{\ensuremath{\not\in}}
#+latex_header: \newunicodechar{‚ÄØ}{\ensuremath{\;\;}}

#+begin_quote
- [[#hello-home][Hello, Home!]]
- [[#pattern-matching][Pattern Matching]]
- [[#local-bindings][Local Bindings]]
- [[#operators][Operators]]
- [[#types][Types]]
- [[#tuples][Tuples]]
- [[#lists][Lists]]
  - [[#pattern-matching-on-lists][Pattern Matching on Lists]]
  - [[#common-methods-on-lists][Common Methods on Lists]]
- [[#list-design-patterns][List ‚ÄòDesign Patterns‚Äô]]
  - [[#map][Map]]
  - [[#filter][Filter]]
  - [[#fold][Fold]]
- [[#algebraic-data-types][Algebraic data types]]
- [[#typeclasses-and-overloading][Typeclasses and overloading]]
- [[#functor][Functor]]
  - [[#identity-axiom][Identity Axiom]]
  - [[#fusion-axiom][Fusion Axiom]]
  - [[#functors-do-not-necessarily-contain-anything][Functors do not necessarily ‚Äòcontain‚Äô anything]]
  - [[#misc-results-about-functors][Misc results about Functors]]
- [[#functor-examples][Functor Examples]]
- [[#applicative][Applicative]]
  - [[#axioms][Axioms]]
  - [[#canonical-form----liftn][Canonical Form -- =liftN=]]
  - [[#monoidal-presentation][Monoidal Presentation]]
- [[#applicative-examples][Applicative Examples]]
- [[#do-notation----subtle-difference-between-applicatives-and-monads][~Do~-Notation ---Subtle difference between applicatives and monads]]
  - [[#do-notation-with-tuples-and-functions][Do-notation with tuples and functions]]
- [[#formal-definition-of-do-notation][Formal Definition of ~Do~-Notation]]
- [[#monad-laws][Monad Laws]]
- [[#monad-examples][Monad Examples]]
- [[#running-example----a-simple-arithmetic-language][Running Example ---A Simple Arithmetic Language]]
- [[#maybe----possibly-failing-computations][Maybe ---Possibly Failing Computations]]
- [[#writer----logging-information-as-we-compute][Writer ---Logging Information as we Compute]]
- [[#reader----accessing-global-read-only-data][Reader ---Accessing ‚ÄòGlobal, read-only, data‚Äô]]
- [[#state----read-and-write-to-local-storage][State ---Read and write to local storage]]
- [[#reads][Reads]]
#+end_quote

* Hello, Home!

#+begin_src haskell :tangle home.hs
main = do putStr "What's your name? "
          name <- getLine
          putStrLn ("It's 2020, " ++ name ++ "! Stay home, stay safe!")
#+end_src

* Pattern Matching

Functions can be defined using the usual ~if_then_else_~ construct, or
   as expressions /guarded/ by Boolean expressions as in mathematics, or
   by /pattern matching/ ---a form of ‚Äòsyntactic comparision‚Äô.

#+begin_src haskell
fact n = if n == 0 then 1 else n * fact (n - 1)

fact' n | n == 0 = 1
       | n != 0 = n * fact' (n - 1)

fact'' 0 = 1
fact'' n = n * fact'' (n - 1)
#+end_src

The above definitions of the factorial function are all equal.

Guards, as in the second version, are a form of ‚Äòmulti-branching conditional‚Äô.

In the final version, when a call, say, ~fact 5~ happens we compare
/syntactically/ whether ~5~ and the first pattern ~0~ are the same. They are not,
so we consider the second case with the understanding that an identifier
appearing in a pattern matches /any/ argument, so the second clause is used.

Hence, when pattern matching is used, order of equations matters: If we
declared the ~n~-pattern first, then the call ~fact 0~ would match it and we end
up with ~0 * fact (-1)~, which is not what we want!

If we simply defined the final ~fact~ using /only/ the first clause, then
~fact 1~ would crash with the error /Non-exhaustive patterns in function fact/.
That is, we may define /partial functions/ by not considering all possible shapes of
inputs.

See also [[https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns][‚Äúview patterns‚Äù]].

* Local Bindings

An equation can be qualified by a ~where~ or ~let~ clause for defining values or
functions used only within an expression.

#+begin_src haskell
  ‚Ä¶e‚Ä¶e‚Ä¶e where e = ‚ÑØùìçùìÖùìá
‚âà let e = ‚ÑØùìçùìÖùìá in ‚Ä¶‚ÑØùìçùìÖùìá‚Ä¶‚ÑØùìçùìÖùìá‚Ä¶‚ÑØùìçùìÖùìá
#+end_src

It sometimes happens in functional programs that one clause of a function needs
/part of/ an argument, while another operators on the /whole/ argument. It it
tedious (and inefficient) to write out the structure of the complete argument
again when referring to it.
Use the ‚Äúas operator‚Äù ~@~ to label all or part of an argument, as in

#+begin_src haskell
f label@(x:y:ys) = ‚ãØ
#+end_src

* Operators
Infix operators in Haskell must consist entiry of ‚Äòsymbols‚Äô such as ~&, ^, !, ‚Ä¶~
rather than alphanumeric characters. Hence, while addition, ~+~, is written infix,
integer division is written prefix with ~div~.

We can always use whatever fixity we like:
- If ~f~ is any /prefix/ binary function, then ~x `f` y~ is a valid /infix/ call.
- If ~‚äï~ is any /infix/ binary operator, then ~(‚äï) x y~ is a valid /prefix/ call.

It is common to fix one argument ahead of time, e.g., ~Œª x ‚Üí x + 1~ is the
successor operation and is written more tersely as ~(+1)~. More generally, ~(‚äïr) =
Œª x ‚Üí x ‚äï r~.

The usual arithmeic operations are ~+, /, *, -~ but ~%~ is used to make fractions.

The Boolean operations are ~==, /=, &&, ||~ for equality, discrepancy,
conjunction, and disjunction.

* Types

Type are inferred, but it is better to write them explicitly so that /you
communicate your intentions to the machine/. If you /think/ that expression ~e~ has
type ~œÑ~ then write ~e :: œÑ~ to /communicate/ that to the machine, which will silently
accept your claim or reject it loudly.

| Type               | Name        | Example Value         |
|--------------------+-------------+-----------------------|
| Small integers     | ~Int~       | ~42~                  |
| Unlimited integers | ~Integer~   | ~7376541234~          |
| Reals              | ~Float~     | ~3.14~ and ~2 % 5~    |
| Booleans           | ~Boolean~   | ~True~ and ~False~    |
| Characters         | ~Char~      | ~'a'~ and ~'3'~       |
| Strings            | ~String~    | ~"salam"~             |
| Lists              | ~[Œ±]~       | ~[]~ or ~[x‚ÇÅ, ‚Ä¶, x‚Çô]~ |
| Tuples             | ~(Œ±, Œ≤, Œ≥)~ | ~(x‚ÇÅ, x‚ÇÇ, x‚ÇÉ)~        |
| Functions          | ~Œ± ‚Üí Œ≤~     | ~Œª x ‚Üí ‚ãØ~             |

/Polymorphism/ is the concept that allows one function to operate on different types.
- A function whose type contains /variables/ is called a /polymorphic function/.
- The simplest polymorphic function is ~id ‚à∑ a -> a~, defined by ~id x = x~.

* Tuples

*Tuples* ~(Œ±‚ÇÅ, ‚Ä¶, Œ±‚Çô)~ are types with values written ~(x‚ÇÅ, ‚Ä¶, x‚Çô)~  where
each ~x·µ¢ :: Œ±·µ¢~. The are a form of ‚Äòrecord‚Äô or ‚Äòproduct‚Äô type.

E.g., ~(True, 3, 'a') :: (Boolean, Int, Char)~.

Tuples are used to ‚Äúreturn multiple values‚Äù from a function.

Two useful functions on tuples of length 2 are:
#+begin_src haskell
fst :: (Œ±, Œ≤) ‚Üí Œ±
fst (x, y) = x

snd :: (Œ±, Œ≤) ‚Üí Œ≤
snd (x, y) = Œ≤
#+end_src

If in addition you ~import Control.Arrow~ then you may use:
#+begin_src haskell
first :: (Œ± ‚Üí œÑ) ‚Üí (Œ±, Œ≤) ‚Üí (œÑ, Œ≤)
first f (x, y) = (f x, y)

second :: (Œ≤ ‚Üí œÑ) ‚Üí (Œ±, Œ≤) ‚Üí (Œ±, œÑ)
second g (x, y) = (x, g y)

(***) :: (Œ± ‚Üí Œ±‚Ä≤) ‚Üí (Œ≤ ‚Üí Œ≤) ‚Üí (Œ±, Œ≤) ‚Üí (Œ±‚Ä≤, Œ≤‚Ä≤)
(f *** g) (x, y) = (f x, g y)

(&&&) :: (œÑ ‚Üí Œ±) ‚Üí (œÑ ‚Üí Œ≤) ‚Üí œÑ ‚Üí (Œ±, Œ≤)
(f &&& g) x = (f x, g x)
#+end_src

* Lists

*Lists* are sequences of items of the same type.

If each ~x·µ¢ ‚à∑ Œ±~ then ~[x‚ÇÅ, ‚Ä¶, x‚Çô] ‚à∑ [Œ±]~.

Lists are useful for functions that want to ‚Äònon-deterministicly‚Äô return a
value:  They return a list of all possible values.

- The /empty list/ is ~[]~
- We ‚Äúcons‚Äùtruct nonempty lists using ~(:) ‚à∑ Œ± ‚Üí [Œ±] ‚Üí [Œ±]~
- Abbreviation: ~[x‚ÇÅ, ‚Ä¶, x‚Çô] = x‚ÇÅ ‚à∂ (x‚ÇÇ ‚à∂ (‚ãØ (x‚Çô ‚à∂ [])))~
- /List comprehensions/: ~[f x | x <- xs, p x]~ is the list of elements
  ~f x~ where ~x~ is an element from list ~xs~ and ~x~ satisfies the property ~p~
  - E.g., ~[2 * x | x <- [2, 3, 4], x < 4] ‚âà [2 * 2, 2 * 3] ‚âà [4, 6]~
- Shorthand notation for segments: ~u~ may be ommitted to yield /infinite lists/
  - ~[l .. u] = [l, l + 1, l + 2, ‚Ä¶, u]~.
  - ~[a, b, .., u] = [a + i * step | i <- [0 .. u - a] ] where step = b - a~

*Strings* are just lists of characters: ~"c‚ÇÄc‚ÇÅ‚Ä¶c‚Çô" ‚âà ['c‚ÇÄ', ‚Ä¶, 'c‚Çô']~.
- Hence, all list methods work for strings.

** Pattern Matching on Lists
*Pattern matching on lists*
#+begin_src haskell
prod []     = 1
prod (x:xs) = x * prod xs

fact n = prod [1 .. n]
#+end_src

If your function needs a case with a list of say, length 3, then you can match
directly on that /shape/ via ~[x, y, z]~ ---which is just an abbreviation for the
shape ~x:y:z:[]~. Likewise, if we want to consider lists of length /at least 3/ then
we match on the shape ~x:y:z:zs~. E.g., define the function that produces the
maximum of a non-empty list, or the function that removes adjacent duplicates
---both require the use of guards.

** Common Methods on Lists
#+begin_src haskell
[x‚ÇÄ, ‚Ä¶, x‚Çô] !! i = x·µ¢
[x‚ÇÄ, ‚Ä¶, x‚Çô] ++ [y‚ÇÄ, ‚Ä¶, y‚Çò] = [x‚ÇÄ, ‚Ä¶, x‚Çô, y‚ÇÄ, ‚Ä¶, y‚Çò]
concat [xs‚ÇÄ, ‚Ä¶, xs‚Çô] = xs‚ÇÄ ++ ‚ãØ ++ xs‚Çô

{- Partial functions -}
head [x‚ÇÄ, ‚Ä¶, x‚Çô] = x‚ÇÄ
tail [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÅ, ‚Ä¶, x‚Çô]
init [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÄ, ‚Ä¶, x‚Çô‚Çã‚ÇÅ]
last [x‚ÇÄ, ‚Ä¶, x‚Çô] = x‚Çô

take k [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÄ, ‚Ä¶, x‚Çñ‚Çã‚ÇÅ]
drop k [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚Çñ, ‚Ä¶, x‚Çô]

sum     [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x‚ÇÄ + ‚ãØ + x‚Çô
prod    [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x‚ÇÄ * ‚ãØ * x‚Çô
reverse [x‚ÇÄ, ‚Ä¶, x‚Çô] =  [x‚Çô, ‚Ä¶, x‚ÇÄ]
elem x  [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x == x‚ÇÄ || ‚ãØ || x == x‚Çô

zip [x‚ÇÄ, ‚Ä¶, x‚Çô] [y‚ÇÄ, ‚Ä¶, y‚Çò]  = [(x‚ÇÄ, y‚ÇÄ), ‚Ä¶, (x‚Çñ, y‚Çñ)] where k = n `min` m
unzip [(x‚ÇÄ, y‚ÇÄ), ‚Ä¶, (x‚Çñ, y‚Çñ)] = ([x‚ÇÄ, ‚Ä¶, x‚Çñ], [y‚ÇÄ, ‚Ä¶, y‚Çñ])
#+end_src

[[https://en.wikipedia.org/wiki/Conjugacy_class][*Duality*]]: Let ~‚àÇf = reverse . f . reverse~, then ~init = ‚àÇ tail~ and
~take k = ‚àÇ (drop k)~; even ~pure . head = ‚àÇ (pure . last)~ where ~pure x = [x]~.

* List ‚ÄòDesign Patterns‚Äô

Many functions have the same ‚Äòform‚Äô or ‚Äòdesign pattern‚Äô, a fact which is
taken advantage of by defining /higher-order functions/ to factor out the
structural similarity of the individual functions.

** Map

~map f xs = [f x | x <- xs]~
- Transform all elements of a list according to the function ~f~.

** Filter
~filter p xs = [x | x <- xs, p x]~
- Keep only the elements of the list that satisfy the predicate ~p~.
- ~takeWhile p xs~ ‚âà Take elements of ~xs~ that satisfy ~p~, but stop stop at
  the first element that does not satisfy ~p~.
- ~dropWhile p xs~ ‚âà Drop all elements until you see one that does not satisfy
  the predicate.
- ~xs = takeWhile p xs ++ dropWhile p xs~.

** Fold
Right-folds let us ‚Äòsum‚Äô up the elements of the list, associating to the right.
#+begin_src haskell
foldr (‚äï) e ‚âà Œª (x‚ÇÄ : (x‚ÇÅ : (‚Ä¶ : (x‚Çô : []))))
              ‚Üí (x‚ÇÄ ‚äï (x‚ÇÅ ‚äï (‚Ä¶ ‚äï (x‚Çô ‚äï e))))
#+end_src

This function just replaces cons ~‚Äú‚à∂‚Äù~ and ~[]~ with ~‚äï~ and ~e~. That's all.
- E.g., replacing ~:,[]~ with themselves does nothing: ~foldr (:) [] = id~.

#+latex: \newpage
/All functions on lists can be written as folds!/
#+begin_src haskell
   h [] = e  ‚àß  h (x:xs) = x ‚äï h xs
‚â°  h = foldr (Œª x rec_call ‚Üí x ‚äï rec_call) e
#+end_src
- Look at the two cases of a function and move them to the two
  first arguments of the fold.
  - ~map f = foldr (Œª x ys ‚Üí f x : ys) []~
  - ~filter p    = foldr (Œª x ys ‚Üí if (p x) then (x:ys) else ys) []~
  - ~takeWhile p = foldr (Œª x ys ‚Üí if (p x) then (x:ys) else []) []~

You can also fold leftward, i.e., by associating to the left:
#+begin_src haskell
foldl (‚äï) e   ‚âà   Œª       (x‚ÇÄ : (x‚ÇÅ : (‚Ä¶ :  (x‚Çô : []))))
                  ‚Üí (((e ‚äï x‚ÇÄ) ‚äï x‚ÇÅ) ‚äï ‚Ä¶ ) ‚äï x‚Çô
#+end_src
Unless the operation ~‚äï~ is associative, the folds are generally different.
- E.g., ~foldl (/) 1 [1..n] ‚âà 1 / n!~ where ~n ! = product [1..n]~.
- E.g., ~-55 = foldl (-) 0 [1..10] ‚â† foldr (-) 0 [1..10] = -5~.

If ~h~ swaps arguments ---~h(x ‚äï y) = h y ‚äï h x~--- then ~h~ swaps folds:

 ~h . foldr (‚äï) e = foldl (‚äù) e‚Ä≤~ where ~e‚Ä≤ = h e~ and ~x ‚äù y = x ‚äï h y~.

E.g., ~foldl (-) 0 xs = - (foldr (+) 0 xs) = - (sum xs)~
 and ~n ! = foldr (*) 1 [1..n] = 1 / foldl (/) 1 [1..n]~.

| /( Floating points are a leaky abstraction! )/ |

* Algebraic data types

When we have ‚Äòpossible scenarios‚Äô, we can make a type to consider each option.
E.g., ~data Door = Open | Closed~ makes a new datatype with two different values.
Under the hood, ~Door~ could be implemented as integers and ~Open~ is 0 and ~Closed~
is 1; or any other implementation ---/all that matters/ is that we have a new
type, ~Door~, with two different values, ~Open~ and ~Closed~.

Usually, our scenarios contain a ‚Äòpayload‚Äô of additional information; e.g., ~data
Door2 = Open | Ajar Int | Closed~. Here, we have a new way to construct ~Door~
values, such as ~Ajar 10~ and ~Ajar 30~, that we could interpret as denoting how far
the door is open/. Under the hood, ~Door2~ could be implemented as pairs of
integers, with ~Open~ being ~(0,0)~, ~Ajar n~ being ~(1, n)~, and ~Closed~ being ~(2, 0)~
---i.e., as the pairs ‚Äú(value position, payload data)‚Äù. Unlike functions, a
value construction such as ~Ajar 10~ cannot be simplified any further; just as the
list value ~1:2:3:[]~ cannot be simplified any further. Remember, the
representation under the hood does not matter, what matters is that we have
three possible /construction forms/ of ~Door2~ values.

Languages, such as C, which do not support such an ‚Äúalgebraic‚Äù approach,
force you, the user, to actually choose a particular representation ---even
though, it does not matter, since we only want /a way to speak of/ ‚Äúdifferent
cases, with additional information‚Äù.

In general, we declare the following to get an ‚Äúenumerated type with payloads‚Äù.
#+begin_src haskell
data D = C‚ÇÄ œÑ‚ÇÅ œÑ‚ÇÇ ‚Ä¶ œÑ‚Çò | C‚ÇÅ ‚ãØ | C‚Çô ‚ãØ deriving Show
#+end_src
There are =n= constructors ~C·µ¢~ that make /different/ values of type ~D~; e.g., ~C‚ÇÄ x‚ÇÅ x‚ÇÇ
‚Ä¶ x‚Çò~ is a ~D~-value whenever each ~x·µ¢~ is a ~œÑ·µ¢~-value. The ~‚Äúderiving Show‚Äù~ at the end
of the definition is necessary for user-defined types to make sure that values
of these types can be printed in a standard form.

We may now define functions on ~D~ by pattern matching on the possible ways to
/construct/ values for it; i.e., by considering the cases ~C·µ¢~.

In-fact, we could have written ~data D Œ±‚ÇÅ Œ±‚ÇÇ ‚Ä¶ Œ±‚Çñ = ‚ãØ~, so that we speak of ‚ÄúD
values /parameterised/ by types Œ±·µ¢‚Äù. E.g., ‚Äúlists whose elements are of type Œ±‚Äù is
defined by ~data List Œ± = Nil | Cons Œ± (List Œ±)~ and, for example, ~Cons 1 (Cons 2
Nil)~ is a value of ~List Int~, whereas ~Cons 'a' Nil~ is of type ~List Char~. ---The
~List~ type is missing the ~‚Äúderiving Show‚Äù~, see below for how to /mixin/ such a
feature.

For example, suppose we want to distinguish whether we have an Œ±-value or a
Œ≤-value, we use ~Either~. Let's then define an example /infix/ function using
pattern matching.
#+begin_src haskell
data Either Œ± Œ≤ = Left Œ± | Right Œ≤

(+++) :: (Œ± ‚Üí Œ±‚Ä≤) ‚Üí (Œ≤ ‚Üí Œ≤‚Ä≤) ‚Üí Either Œ± Œ≤ ‚Üí Either Œ±‚Ä≤ Œ≤‚Ä≤
(f +++ g) (Left  x) = Left $ f x
(f +++ g) (Right x) = Right $ g x

right :: (Œ≤ ‚Üí œÑ) ‚Üí Either Œ± Œ≤ ‚Üí Either Œ± œÑ
right f = id +++ f
#+end_src
The above ~(+++)~ can be found in ~Control.Arrow~ and is also known as ~either~ in the
standard library.

* Typeclasses and overloading

/Overloading/ is using the same name to designate operations ‚Äúof the same nature‚Äù
on values of different types.

E.g., the ~show~ function converts its argument into a string; however, it is not
polymorphic: We cannot define ~show :: Œ± ‚Üí String~ with one definition since some
items, like functions or infinite datatypes, cannot be printed and so this is
not a valid type for the function ~show~.

Haskell solves this by having ~Show~ /typeclass/ whose /instance types/ ~Œ±~ each
implement a definition of the /class method/ ~show~. The type of ~show~ is written
~Show Œ± => Œ± -> String~: /Given an argument of type ~Œ±~, look in the global listing of
~Show~ instances, find the one for ~Œ±~, and use that;/ if ~Œ±~ has no ~Show~ instance,
then we have a type error. One says ‚Äúthe type variable ~Œ±~ has is /restricted/ to be
a ~Show~ instance‚Äù ---as indicated on the left side of the ~‚Äú=>‚Äù~ symbol.

E.g., for the ~List~ datatype we defined, we may declare it to be ‚Äòshowable‚Äô like
so:
#+begin_quote
#+begin_src haskell -n 1
  instance Show a => Show (List a) where
    show Nil         = "Nope, nothing here"
    show (Cons x xs) = "Saw " ++ show x ++ ", then " ++ show xs
#+end_src
#+end_quote
That is:
1. /If ~a~ is showable, then ~List a~ is also showable./
2. /Here's how to show ~Nil~ directly./
3. /We show ~Cons x xs~ by using the ~show~ of ~a~ on ~x~, then recursively showing ~xs~./

|               | Common Typeclasses                                 |
|---------------+----------------------------------------------------|
| ~Show~        | Show elements as strings, ~show~                   |
| ~Read~        | How to read element values from strings, ~read~    |
| ~Eq~          | Compare elements for equality, ~==~                |
| ~Num~         | Use literals ~0, 20, ‚Ä¶,~ and arithmetic ~+, *, -~  |
| ~Ord~         | Use comparison relations ~>, <, >=, <=~            |
| ~Enum~        | Types that can be listed, ~[start .. end]~         |
| ~Monoid~      | Types that model ‚Äò(untyped) composition‚Äô           |
| ~Functor~     | /Type formers/ that model effectful computation    |
| ~Applicative~ | Type formers that can sequence effects             |
| ~Monad~       | Type formers that let effects depend on each other |

The ~Ord~ typeclass is declared ~class Eq a => Ord a where ‚ãØ~, so that all ordered
types are necessarily also types with equality. One says ~Ord~ is a /subclass/ of
~Eq~; and since subclasses /inherit/ all functions of a class, we may always replace
~(Eq a, Ord a) => ‚ãØ~ by ~Ord a => ‚ãØ~.

You can of-course define your own typeclasses; e.g., the ~Monoid~ class in Haskell
could be defined as follows.
#+begin_src haskell
class Semigroup a where
  (<>) :: a -> a -> a  {- A way to ‚Äúcompose‚Äù elements together -}
  {- Axiom: (x <> y) <> z = x <> (y <> z) -}

class Semigroup a => Monoid a where
  mempty :: a   {- Axiom: This is a ‚Äòno-op‚Äô, identity, for composition <> -}
#+end_src
Example monoids ~(Œ±, <>, mempty)~ include ~(Int, +, 0)~, ~([Œ±], ++, [])~, and
 (Program statements, sequence ‚Äú;‚Äù, the empty statement) ---this
last example is approximated as ~Term~ with ‚Äòlet-in‚Äô clauses at the end of this
cheatsheet. /Typeclasses are interfaces, possibly with axioms specifying their
behaviour./

As shown earlier, Haskell provides a the ~deriving~ mechanism for making it easier
to define instances of typeclasses, such as ~Show, Read, Eq, Ord, Enum~. How?
Constructor names are printed and read as written as written in the ~data~
declaration, two values are equal if they are formed by the same construction,
one value is less than another if the constructor of the first is declared in
the ~data~ definition before the constructor of the second, and similarly for
listing elements out.
* Functor

/Functors are type formers that ‚Äúbehave‚Äù like collections: We can alter their/
/‚Äúelements‚Äù without messing with the ‚Äòcollection structure‚Äô or ‚Äòelement
positions‚Äô./ The well-behavedness constraints are called /the functor axioms/.
#+begin_src haskell
class Functor f where
  fmap :: (Œ± ‚Üí Œ≤) ‚Üí f Œ± ‚Üí f Œ≤

(<$>) = fmap {- An infix alias -}
#+end_src

The axioms cannot be checked by Haskell, so we can form instances that fail to
meet the implicit specifications ---two examples are below.

** Identity Axiom

*Identity Law*: ~fmap id = id~

/Doing no alteration to the contents of a collection does nothing to the collection./

This ensures that ‚Äúalterations don't needlessly mess with element values‚Äù
e.g., the following is not a functor since it does.
#+begin_src haskell :tangle probably.hs
{- I probably have an item -}
data Probably a = Chance a Int

instance Functor Probably where
  fmap f (Chance x n) = Chance (f x) (n `div` 2)
#+end_src

** Fusion Axiom
*Fusion Law:* ~fmap f . fmap g = fmap (f . g)~

/Reaching into a collection and altering twice is the same as reaching in and
altering once./

This ensures that ‚Äúalterations don't needlessly mess with collection structure‚Äù;
e.g., the following is not a functor since it does.

#+begin_src haskell :tangle pocket.hs
import Prelude hiding (Left, Right)

{- I have an item in my left or my right pocket -}
data Pocket a = Left a | Right a

instance Functor Pocket where
  fmap f (Left  x) = Right (f x)
  fmap f (Right x) = Left  (f x)
#+end_src

** Functors do not necessarily ‚Äòcontain‚Äô anything

It is important to note that functors model well-behaved container-like types,
but of-course the types do not actually need to contain anything at all! E.g.,
the following is a valid functor.
#+begin_src haskell :tangle Liar.hs
{- ‚ÄúI totally have an Œ±-value, it's either here or there.‚Äù Lies! -}
data Liar Œ± = OverHere Int | OverThere Int

instance Functor Liar where
  fmap f (OverHere  n) = OverHere  n
  fmap f (OverThere n) = OverThere n
#+end_src
Notice that if we altered ~n~, say by dividing it by two, then we break the
identity law; and if we swap the constructors, then we break the fusion law.
Super neat stuff!

In general, functors take something boring and generally furnish it with
‚Äòcoherent‚Äô structure, but *there is not necessarily an Œ± ‚Äòinside‚Äô f Œ±*.
E.g., ~f Œ± = (Œµ ‚Üí Œ±)~ has as values ‚Äúrecipes for forming an Œ±-value‚Äù,
but unless executed, there is no ~Œ±~-value.

** Misc results about Functors

#+latex: \vspace{0.5em}
- ~fmap f xs~ ‚âà /for each/ element ~x~ in the ‚Äòcollection‚Äô ~xs~, yield ~f x~.
- Haskell can usually ~derive~ functor instances since they are [[http://archive.fo/U8xIY][unique]]: Only one
  possible definition of ~fmap~ will work.
- Reading the functor axioms left-to-right, they can be seen as /optimisation laws/
  that make a program faster by reducing work.
- The two laws together say /fmap distributes over composition/:
  ~fmap (f‚ÇÅ . f‚ÇÇ . ‚ãØ . f‚Çô) = fmap f‚ÇÅ . ‚ãØ . fmap f‚Çô~ for ~n ‚â• 0~.

*Naturality Theorems:* If ~p ‚à∑ f a ‚Üí g a~ for some /functors/ ~f~ and ~g~,
then ~fmap f . p = p . fmap f~ for any /function/ ~f~.

Hence, any generic property ~p ‚à∑ f Œ± ‚Üí Œµ~ is invariant over fmaps:
~p(fmap¬†f¬†xs)¬†=¬†p‚ÄØxs~. E.g., the length of a list does not change even when an
fmap is applied.

* Functor Examples

Let ~f‚ÇÅ, f‚ÇÇ~ be functors and ~Œµ~ be a given type.

| Type Former                                                                                                 | ~f Œ±~                  | ~f <$> x~                             |
|-------------------------------------------------------------------------------------------------------------+------------------------+---------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity][Identity]]  | ~Œ±~                    | ~f <$> x =  x~                        |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const][Constant]]       | ~Œµ~                    | ~f <$> x = x~                         |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-List.html][List]]                              | ~[Œ±]~                  | ~f <$> [x‚ÇÄ, ‚Ä¶, x‚Çô] = [f x‚ÇÄ, ‚Ä¶, f x‚Çô]~ |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either][Either]]                | ~Either Œµ Œ±~           | ~f <$> x = right f~                   |
|-------------------------------------------------------------------------------------------------------------+------------------------+---------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html#t:Product][Product]]     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~         | ~f <$> (x, y) = (f <$> x, f <$> y)~   |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose][Composition]] | ~f‚ÇÅ (f‚ÇÇ Œ±)~            | ~f <$> x = (fmap f) <$> x~            |
| [[http://comonad.com/reader/2012/abstracting-with-applicatives/][Sum]]                                      | ~Either (f‚ÇÅ Œ±) (f‚ÇÇ Œ±)~ | ~f <$> ea = f +++ f~                  |
|-------------------------------------------------------------------------------------------------------------+------------------------+---------------------------------------|
| [[http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]]            | ~(Œµ, Œ±)~               | ~f <$> (e, x) = (e, f x)~             |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html][Reader]]                    | ~Œµ ‚Üí Œ±~                | ~f <$> g = f . g~                     |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]]             | ~Œµ ‚Üí (Œµ, Œ±)~           | ~f <$> g = second f . g~              |

Notice that writer is the product of the constant and the identity functors.

Unlike reader, the type former ~f Œ± = Œ± ‚Üí Œµ~ is /not/ a functor since there is no
way to implement ~fmap~. In contrast, ~f Œ± = (Œ± ‚Üí Œµ, Œ±)~ /does/ have an implementation
of ~fmap~, but it is not lawful.

* Applicative
/Applicatives are collection-like types that can apply collections of functions
to collections of elements./

In particular, /applicatives can fmap over multiple arguments/; e.g., if we try to
add ~Just 2~ and ~Just 3~, we find =(+) <$> Just 2 :: Maybe (Int ‚Üí Int)= and this is
not a function and so cannot be applied further to ~Just 3~ to get ~Just 5~.
We have both the function and the value wrapped up, so we need a way to apply
the former to the latter. The answer is ~(+) <$> Just 2 <*> Just 3~.

#+begin_src haskell
class Functor f => Applicative f where
  pure   :: a -> f a
  (<*>)  :: f (a -> b) -> f a -> f b  {- ‚Äúapply‚Äù -}

{- Apply associates to the left: p <*> q <*> r = (p <*> q) <*> r) -}
#+end_src

The method ~pure~ lets us inject values, to make ‚Äòsingleton collections‚Äô.

- /Functors transform values inside collections; applicatives can additionally
  combine values inside collections./
- Exercise: If ~Œ±~ is a monoid, then so too is ~f Œ±~ for any applicative ~f~.

** Axioms
The applicative axioms ensure that apply behaves like usual functional application:

- Identity: ~pure id <*> x = x~ ---c.f., ~id x = x~
- Homomorphism: ~pure f <*> pure x = pure (f x)~ ---it really is function application
  on pure values!
  - Applying a non-effectful function to a non-effectful argument in an effectful
    context is the same as just applying the function to the argument and then
    injecting the result into the content.
- Interchange: ~p <*> pure x = pure ($ x) <*> p~ ---c.f., ~f x = ($ x) f~
  - Functions ~f~ take ~x~ as input ‚âà Values ~x~ project functions ~f~ to particular values
  - When there is only one effectful component, then it does not matter whether
    we evaluate the function first or the argument first, there will still only be
    one effect.
  - Indeed, this is equivalent to the law: ~pure f <*> q = pure (flip ($)) <*> q <*> pure f~.

- Composition: ~pure (.) <*> p <*> q <*> r = p <*> (q <*> r)~
   ---c.f., ~(f . g) . h = f . (g . h)~.

If we view ~f Œ±~ as an ‚Äúeffectful computation on Œ±‚Äù, then the above laws ensure
~pure~ creates an ‚Äúeffect free‚Äù context. E.g., if ~f Œ± = [Œ±]~ is considered
‚Äúnondeterminstic Œ±-values‚Äù, then ~pure~ just treats usual Œ±-values as
nondeterminstic but with no ambiguity, and ~fs <*> xs~ reads ‚Äúif we
nondeterminsticly have a choice ~f~ from ~fs~, and we nondeterminsticly an ~x~ from
~xs~, then we nondeterminsticly obtain ~f x~.‚Äù More concretely, if I'm given
randomly addition or multiplication along with the argument 3 and another
argument that could be 2, 4, or 6, then the result would be obtained by
considering all possible combinations: ~[(+), (*)] <*> pure 3 <*> [2, 4, 6] =
[5,7,9,6,12,18]~. The name ~‚Äú<*>‚Äù~ is suggestive of this ‚Äòcartesian product‚Äô nature.

Given a definition of apply, the definition of ~pure~ may be obtained
by unfolding the identity axiom.

Using these laws, we regain ~fmap~ thereby further cementing that applicatives
model ‚Äúcollections that can be functionally applied‚Äù: ~f <$> x = pure f <*> x~.
( Hence, every applicative is a functor whether we like it or not. )
- The homomorphism law now becomes: ~pure . f = fmap f . pure~.

  - This is the ‚Äúnaturality law‚Äù for ~pure~.

** Canonical Form -- =liftN=

[[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][The laws]] may be interpreted as left-to-right rewrite rules and so are a
 procedure for transforming any applicative expression into the canonical form
 of ‚Äúa pure function applied to effectful arguments‚Äù: ~pure f <*> x‚ÇÅ <*> ‚ãØ <*>
 x‚Çô~. In this way, one can compute in-parallel the, necessarily independent, ~x·µ¢~
 then combine them together.

Notice that the canonical form generalises ~fmap~ to ~n~-arguments:
Given ~f ‚à∑ Œ±‚ÇÅ ‚Üí ‚ãØ ‚Üí Œ±‚Çô ‚Üí Œ≤~ and ~x·µ¢ ‚à∑ f Œ±·µ¢~, we obtain an ~(f Œ≤)~-value.
The case of ~n = 2~ is called ~liftA2~, ~n = 1~ is just ~fmap~, and for ~n = 0~ we have
~pure~!
** Monoidal Presentation

Notice that ~lift2A~ is essentially the cartesian product in the setting of lists,
or ~(<&>)~ below ---c.f., ~sequenceA :: Applicative f ‚áí [f a] ‚Üí f [a]~.

#+begin_src haskell
(<&>) :: f a ‚Üí f b ‚Üí f (a, b)   {- Not a standard name! -}
(<&>) = liftA2 (,)  -- i.e., p <&> q = (,) <$> p <*> q
#+end_src
This is a pairing operation with properties of ~(,)~ mirrored at the applicative level:
#+begin_src haskell
{- Pure Pairing -} pure x <&> pure y = pure (x, y)
{- Naturality   -} (f &&& g) <$> (u <&> v) = (f <$> u) <&> (g <&> v)

{- Left Projection  -} fst <$> (u <&> pure ()) = u
{- Right Projection -} snd <$> (pure () <&> v)  = v
{- Associtivity     -} assocl <$> (u <&> (v <&> w)) = (u <&> v) <&> w
#+end_src
The final three laws above suffice to prove the original applicative axioms, and so
we may define ~p <*> q = uncurry ($) <$> (p <&> q)~.

* Applicative Examples

Let ~f‚ÇÅ, f‚ÇÇ~ be functors and let ~Œµ~ a type.

| Functor                                                                                                     | ~f Œ±~                  | ~f <*> x~                                   |
|-------------------------------------------------------------------------------------------------------------+------------------------+---------------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity][Identity]]  | ~Œ±~                    | ~f <*> x = f x~                             |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const][Constant]]       | ~Œµ~                    | ~e <*> d = e <> d~                          |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-List.html][List]]                              | ~[Œ±]~                  | =fs <*> xs = [f x ‚à£ f <- fs, x <- xs]=      |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either][Either]]                | ~Either Œµ Œ±~           | ~ef <*> ea = right (Œª f ‚Üí right f ea) ef~   |
|-------------------------------------------------------------------------------------------------------------+------------------------+---------------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose][Composition]] | ~f‚ÇÅ (f‚ÇÇ Œ±)~            | ~f <*> x = (<*>) <$> f <*> x~               |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html#t:Product][Product]]     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~         | ~(f, g) <*> (x, y) = (f <*> x, g <*> y)~    |
| [[http://comonad.com/reader/2012/abstracting-with-applicatives/][Sum]]                                      | ~Either (f‚ÇÅ Œ±) (f‚ÇÇ Œ±)~ | Challenge: Assume ~Œ∑ ‚à∑ f‚ÇÅ a ‚Üí f‚ÇÇ a~         |
|-------------------------------------------------------------------------------------------------------------+------------------------+---------------------------------------------|
| [[http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]]            | ~(Œµ, Œ±)~               | ~(a , f) <*> (b, x) = (a <> b, f x)~        |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html][Reader]]                    | ~Œµ ‚Üí Œ±~                | ~f <*> g = Œª e ‚Üí f e (g e)~  ---c.f., ~SKI~ |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]]             | ~Œµ ‚Üí (Œµ, Œ±)~           | ~sf <*> sa = Œª e ‚Üí let (e‚Ä≤, f) = sf e~      |
|                                                                                                             |                        | ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ  ~in second f (sa e‚Ä≤)~    |

In the writer and constant cases, we need ~Œµ~ to also be a monoid.
When Œµ is /not/ a monoid, then those two constructions give examples of functors
that are /not/ applicatives ---since there is no way to define ~pure~.
In contrast, ~f Œ± = (Œ± ‚Üí Œµ) ‚Üí Maybe Œµ~ is not an applicative since no
definition of apply is lawful.

Since readers ~((->) r)~ are applicatives, we may, for example, write ~(‚äï) <$> f
<*> g~ as a terse alternative to the ‚Äúpointwise ‚äï‚Äù method ~Œª x ‚Üí f x ‚äï g x~. E.g.,
using ~(&&)~ gives a simple way to chain predicates.

* ~Do~-Notation ---Subtle difference between applicatives and monads
Recall the ~map~ operation on lists, we could define it ourselves:
#+begin_src haskell :tangle delme.hs
map' :: (Œ± -> Œ≤) -> [Œ±] -> [Œ≤]
map' f []     = []
map' f (x:xs) = let y  = f x
                    ys = map' f xs
                in  (y:ys)
#+end_src
If instead the altering function ~f~ returned effectful results,
then we could gather the results along with the effect:
#+begin_src haskell :tangle delme1.hs
{-# LANGUAGE ApplicativeDo #-}

mapA :: Applicative f => (a -> f b) -> [a] -> f [b]
mapA f []     = pure []
mapA f (x:xs) = do y  <- f x
                   ys <- mapA f xs
                   pure (y:ys)
                {- ‚âà (:) <$> f x <*> mapA f xs -}
#+end_src

Applicative syntax can be a bit hard to write, whereas ~do~-notation is more
natural and reminiscent of the imperative style used in defining ~map'~ above. For
instance, the intuition that ~fs <*> ps~ is a cartesian product is clearer in
do-notation: ~fs <*> ps ‚âà do {f ‚Üê fs; x ‚Üê ps; pure (f x)}~ where the right side is
read /‚Äúfor-each f in fs, and each x in ps, compute f x‚Äù/.

#+latex: \columnbreak

[[https://dl.acm.org/doi/pdf/10.1145/3241625.2976007][In-general]], ~do {x‚ÇÅ ‚Üê p‚ÇÅ; ‚Ä¶; x‚Çô ‚Üê p‚Çô; pure e} ‚âà pure (Œª x‚ÇÅ ‚Ä¶ x‚Çô ‚Üí e) <*> p‚ÇÅ <*> ‚ãØ
<*> p‚Çô~ *provided* ~p·µ¢~ does not mention ~x‚±º~ for ~j < i~; but =e= may refer to all ~x·µ¢~. If
any ~p·µ¢~ mentions an earlier ~x‚±º~, then we could not translate the ~do~-notation into
an applicative expression.

If ~do {x ‚Üê p; y ‚Üê qx; pure e}~ has ~qx~ being an expression *depending* on ~x~,
then we could say this is an abbreviation for ~(Œª x ‚Üí (Œª y ‚Üí e) <$> qx) <$> p~
but this is of type ~f (f Œ≤))~. Hence, to allow later computations to depend
on earlier computations, we need a method ~join :: f (f Œ±) ‚Üí f Œ±~ with which
we define  ~do {x ‚Üê p; y ‚Üê qx; pure e} ‚âà join $ ~(Œª x -> (Œª y ‚Üí e) <$> qx) <$> p~.

Applicatives with a ~join~ are called monads and they give us a *‚Äúprogrammable
semicolon‚Äù*. Since later items may depend on earlier ones, ~do {x ‚Üê p; y ‚Üê q;
pure e}~ could be read /‚Äúlet x be the value of computation p, let y be the value
of computation q, then combine the values via expression e‚Äù/. Depending on how
~<*>~ is implemented, such ‚Äòlet declarations‚Äô could short-circuit (~Maybe~) or be
nondeterministic (~List~) or have other effects such as altering state.

As the ~do~-notation clearly shows, the primary difference between =Monad= and
=Applicative= is that =Monad= allows dependencies on previous results, whereas
=Applicative= does not.

** Do-notation with tuples and functions

Do-syntax also works with tuples and functions --c.f., reader monad below---
since they are monadic; e.g., every clause ~x <- f~ in a functional do-expression
denotes the resulting of applying ~f~ to the (implicit) input.
More concretely:
#+begin_src haskell
go :: (Show a, Num a) => a -> (a, String)
go = do {x <- (1+); y <- show; return (x, y)}

-- go 3 = (4, "3")
#+end_src

Likewise, tuples, lists, etc.

* Formal Definition of ~Do~-Notation

For a general applicative ~f~, a ~do~ expression has the form ~do {C; r}~, where ~C~ is
a (possibly empty) list of commands separated by semicolons, and ~r~ is an
expression of type ~f Œ≤~, which is also the type of the entire ~do~ expression. Each
command takes the form ~x ‚Üê p~, where ~x~ is a variable, or possibly a pattern; if ~p
:: f Œ±~ then ~x :: Œ±~. In the particular case of the anonymous variable, ~_ ‚Üê p~ may
be abbreviated to ~p~.

The translation of a ~do~ expression into ~<*>/join~ operations and ~where~ clauses is
governed by three rules ---the last one only applies in the setting of a monad.
#+begin_src haskell
(1)  do {r}           = r
(2A) do {x ‚Üê p; C; r} = q <*> p where q x = do {C; r} --Provided x ‚àâ C
(2M) do {x ‚Üê p; C; r} = join $ map q p where q x = do {C; r}

{- Fact: When x ‚àâ C, (2A) = (2M). -}
#+end_src

By definition chasing and induction on the number of commands ~C~, we have:
#+begin_src haskell
[CollapseLaw]  do {C; do {D; r}} = do {C; D; r}
#+end_src
Likewise:
#+begin_src haskell
[Map ] fmap f p = do {x ‚Üê p; pure (f x)} -- By applicative laws
[Join] join ps  = do {p ‚Üê ps; p}         -- By functor laws
#+end_src

*Do-Notation Laws*: Here are some desirable usability properties of ~do~-notation.
#+begin_src haskell
[RightIdentity]  do {B; x ‚Üê p; pure x}       = do {B; p}
[LeftIdentity ]  do {B; x ‚Üê pure e; C; r}    = do {B; C[x ‚âî e]; r[x ‚âî e]}
[Associtivity ]  do {B; x ‚Üê do {C; p}; D; r} = do {B; C; x ‚Üê p; D; r}
#+end_src

Here, ~B, C, D~ range over sequences of commands and ~C[x ‚âî e]~ means the sequence ~C~
with all free occruences of ~x~ replaced by ~e~.

- Associtivity gives us a nice way to ‚Äòinline‚Äô other calls.
- The LeftIdentity law, read right-to-left, lets us ‚Äúlocally give a name‚Äù to the
  possibly complex expression ~e~.

  If ~pure~ forms a singleton collection, then LeftIdentity is a ‚Äúone-point rule‚Äù:
  We consider /all/ ~x ‚Üê pure e~, but there is only /one/ such ~x~, namely ~e~!

In the applicative case, where the clauses are independent, we can prove, say,
~RightIdentity~ using the identity law for applicatives ---which says essentially

~do {x <- p; pure x} = p~--- then apply induction on the length of ~B~.

What axioms are needed for the monad case to prove the ~do~-notation laws?

* Monad Laws
Here is the definition of the monad typeclass.
#+begin_src haskell :tangle del_4.hs
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b

(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
f <=< g = join . fmap f . g
#+end_src

Where's ~join~!? Historically, monads entered Haskell first with interface ~(>>=),
return~; later it was realised that ~return = pure~ and the relationship with
applicative was cemented.

‚ÄòBind‚Äô ~(>>=)~ is definable from ~join~ by ~ma >>= f = join (fmap f ma)~, and, for
this reason, bind is known as ‚Äúflat map‚Äù or ‚Äúconcat map‚Äù in particular
instances. For instance, the second definition of ~do~-notation could be
expressed:
#+begin_src haskell
(2M‚Ä≤) do {x ‚Üê p; C; r} = p >>= q where q x = do {C; r}
#+end_src
Conversely, ~join ps = do {p ‚Üê ps; p} = ps >>= id~. Likewise, with (2M‚Ä≤), note how
~(<*>)~ can be defined directly in-terms of ~(>>=)~

---c.f., ~mf <*> mx = do {f ‚Üê mf;
x ‚Üê mx; return (f x)}~.

Since ~fmap f p = do {x ‚Üê p; return (f x)} = p >>= return . f~, in the past monad
did not even have functor as a superclass ---c.f., [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:liftM][liftM]].

The properties of ~>>=, return~ that prove the desired ~do~-notation laws are:
#+begin_src haskell
[LeftIdentity ] return a >>= f   ‚â°  f a
[RightIdentity] m >>= return     ‚â°  m
[Associtivity ] (m >>= f) >>= g  ‚â°  m >>= (\x -> f x >>= g)
                i.e.,   (m  >>=  (\x -> f x))  >>=  g
                       = m  >>=  (\x -> f x    >>=  g)
#+end_src

Equivalently, show the ‚Äòfish‚Äô ~(<=<)~ is associative with identity being ~pure~
---c.f., monoids!

It is pretty awesome that ~(>>=), return~ give us a functor, an applicative, and
(dependent) do-notation! Why? Because bind does both the work of ~fmap~ and ~join~.
Thus, ~pure, fmap, join~ suffice to characterise a monad.

| /Join determines how a monad behaves!/ |

The monad laws can be expressed in terms of ~join~ [[https://en.wikibooks.org/wiki/Haskell/Category_theory#The_monad_laws_and_their_importance][directly]]:
#+begin_src haskell
[Associativity] join . fmap join = join . join
{- The only two ways to get from ‚Äúm (m (m Œ±))‚Äù to ‚Äúm Œ±‚Äù are the same. -}

[Identity Laws] join. fmap pure = join . pure = id
{- Wrapping up ‚Äúm Œ±‚Äù gives an ‚Äúm (m Œ±)‚Äù which flattens to the original element. -}
#+end_src

Then, notice that the (free) naturality of join is:
#+begin_src haskell
join . fmap (fmap f) = fmap f . join  ‚à∑  m (m Œ±) ‚Üí m Œ≤
#+end_src

Again, note that ~join~ doesn't merely flatten a monad value, but rather performs
the necessary logic that determines /how the monad behaves/.

E.g., suppose ~m Œ± = Œµ ‚Üí (Œµ, Œ±)~ is the type of ~Œ±~-values that can be configured
according to a fixed environment type ~Œµ~, along with the possibly updated
configuration ---i.e., functions ~Œµ ‚Üí (Œµ, Œ±)~. Then any ~a ‚à∂ Œµ ‚Üí (Œµ, Œµ ‚Üí (Œµ, Œ±))~ in ~m
 (m Œ±)~ can be considered an element of ~m Œ±~ if we /propagate the environment
configuration/ through the outer layer to obtain a new configuration for the
inner layer: ~Œª e ‚Üí let (e‚Ä≤, a‚Ä≤) = a e in a‚Ä≤ e‚Ä≤~. The join dictates how a
configuration is /modified then passed along/: We have two actions, ~a~ and ~a‚Ä≤~, and
join has /sequenced/ them by pushing the environment through the first thereby
modifying it then pushing it through the second.

* Monad Examples

Let ~f‚ÇÅ, f‚ÇÇ~ be functors and let ~Œµ~ a type.

| Applicative                                                                                                 | ~m Œ±~          | ~join :: m (m Œ±) ‚Üí m Œ±~                                             |
|-------------------------------------------------------------------------------------------------------------+----------------+---------------------------------------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity][Identity]]  | ~Œ±~            | ~Œª x ‚Üí x~                                                           |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const][Constant]]       | ~Œµ~            | ~Œª x ‚Üí x~  ---Shucks!                                               |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-List.html][List]]                              | ~[Œ±]~          | ~Œª xss ‚Üí foldr (++) [] xss~                                         |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either][Either]]                | ~Either Œµ Œ±~   | Exercise ^_^                                                        |
|-------------------------------------------------------------------------------------------------------------+----------------+---------------------------------------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose][Composition]] | ~f‚ÇÅ (f‚ÇÇ Œ±)~    | [[https://stackoverflow.com/q/7040844/3550444][Nope! Not a monad!]] |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html#t:Product][Product]]     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~ | ~Œª p ‚Üí (fst <$> p, snd <$> p)~                                      |
|-------------------------------------------------------------------------------------------------------------+----------------+---------------------------------------------------------------------|
| [[http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]]            | ~(Œµ, Œ±)~       | ~Œª (e, (e‚Ä≤, a)) ‚Üí (e <> e‚Ä≤, a)~                                     |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html][Reader]]                    | ~Œµ ‚Üí Œ±~        | ~Œª ra ‚Üí Œª e ‚Üí ra e e~                                               |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]]             | ~Œµ ‚Üí (Œµ, Œ±)~   | ~Œª ra ‚Üí Œª e ‚Üí let (e‚Ä≤, a) = ra e in a e‚Ä≤~                           |

In writer, we need ~Œµ~ to be a monoid.

- Notice how, in writer, join merges the outer context with the inner context:
  /Sequential writes are mappended together!/
- If ~pure~ forms ‚Äòsingleton containers‚Äô then ~join~ flattens containers of containers
  into a single container.

Excluding the trivial monoid, the constant functor is /not/ a monad: It fails the
monad identity laws for join. Similarly, ~f Œ± = Maybe (Œ±, Œ±)~ is an applicative
but /not/ a monad ---since there is no lawful definition of ~join~. Hence,
applicatives are strictly more generally than monads.

* Running Example ---A Simple Arithmetic Language

Let's start with a weak language:
#+begin_src haskell :tangle simple_terms.hs
data Term = Int Int | Div Term Term deriving Show

thirteen = Int 1729 `Div` (Int 133 `Div` Int 1)
boom     = Int 1729 `Div` (Int 12  `Div` Int 0)

eval‚ÇÄ :: Term -> Int
eval‚ÇÄ (Int n) =  n
eval‚ÇÄ (n `Div` d) = let top    = eval‚ÇÄ n
                        bottom = eval‚ÇÄ d
                    in  top `div` bottom
#+end_src

How do we accomodate safe division by zero? Print to the user what's happening
at each step of the calcuation? Have terms that access ‚Äòglobal‚Äô variables? Have
terms that can store named expressions then access them later?

We'll make such languages and their ~eval~'s will be nearly just as simple as this
one (!) but accomodate these other issues.

* [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Maybe.html][Maybe]] ---Possibly Failing Computations
Safe evaluator: No division errors.
#+begin_src haskell :tangle simple_terms.hs
eval‚ÇÅ :: Term -> Maybe Int
eval‚ÇÅ (Int n) = pure n
eval‚ÇÅ (n `Div` d) = do t <- eval‚ÇÅ n
                       b <- eval‚ÇÅ d
                       if b == 0 then Nothing else pure (t `div` b)
#+end_src
Exercise: Rewrite ~eval·µ¢~ without ~do~-notation and you'll end-up with nested case
analysis leading into a straicase of code that runs right off the page.

- Applicative is enough for ~eval‚ÇÅ, eval‚ÇÇ, eval‚ÇÉ~, but ~eval‚ÇÑ~ needs ~Monad~.

* [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]] ---Logging Information as we Compute

Use a pair type ~W Œµ Œ±~ to keep track of an environment ~Œµ~ and a value ~Œ±~.
#+begin_src haskell :tangle simple_terms.hs
data Writer Œµ Œ± = W Œµ Œ± deriving Show

write :: Œµ -> Writer Œµ ()
write e = W e ()

instance Functor (Writer Œµ) where
  fmap f (W e a) = W e (f a)
#+end_src
Aggregate, merge, environments using their monoidal operation.
#+begin_src haskell :tangle simple_terms.hs
instance Monoid Œµ => Applicative (Writer Œµ) where
  pure a = W mempty a
  (W e f) <*> (W d a) = W (e <> d) (f a)

instance Monoid Œµ => Monad (Writer Œµ) where
  (>>=) = \ ma f -> join (pure f <*> ma)
    where join (W e (W d a)) = W (e <> d) a
#+end_src

An evaluator that prints to the user what's going on.
#+begin_src haskell :tangle simple_terms.hs
eval‚ÇÇ :: Term -> Writer String Int
eval‚ÇÇ it@(Int n) = W ("\n Evaluating: " ++ show it) n
eval‚ÇÇ it@(n `Div` d) = do write $ "\n Evaluating: " ++ show it
                          t <- eval‚ÇÇ n
                          b <- eval‚ÇÇ d
                          pure $ (t `div` b)

-- Try this! With ‚Äúboom‚Äù, we get to see up to the boint of the error ^_^
-- let W e x = eval‚ÇÇ thirteen in putStrLn e
#+end_src

#+latex: \vspace{-1em}
* [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2][Reader]] ---Accessing ‚ÄòGlobal, read-only, data‚Äô
#+latex: \hspace{-1.5em}
Use a function type ~Œµ ‚Üí Œ±~ to get ~Œ±~-values that ‚Äòreads‚Äô from a configuration
environment Œµ.
#+begin_src haskell :tangle terms_with_vars.hs
data Reader Œµ Œ± = R {run :: Œµ -> Œ±}

instance Functor (Reader Œµ) where
  fmap f (R g) = R $ f . g

instance Applicative (Reader Œµ) where
  pure a = R $ const a
  (R f) <*> (R g) = R $ \e -> f e (g e) {- ‚ÄúS‚Äù combinator -}

instance Monad (Reader Œµ) where
  ma >>= f = join (pure f <*> ma)
    where join (R rf) = R $ \e -> run (rf e) e
#+end_src

A language with access to global variables; uninitialised variables are 0 by
default.
#+begin_src haskell :tangle terms_with_vars.hs
data Term = Int Int | Div Term Term | Var String deriving Show

type GlobalVars = [(String, Int)]

valuefrom :: String -> GlobalVars -> Int
valuefrom x gvs = maybe 0 id $ lookup x gvs

eval‚ÇÉ :: Term -> Reader GlobalVars Int
eval‚ÇÉ (Int x) = pure x
eval‚ÇÉ (Var x) = R $ \e -> x `valuefrom` e
eval‚ÇÉ (n `Div` d) = do t <- eval‚ÇÉ n
                       b <- eval‚ÇÉ d
                       pure (t `div` b)

state    = [("x", 1729), ("y", 133)] :: GlobalVars
thirteen = Var "x" `Div` (Var "y" `Div` Int 1)
-- run (eval‚ÇÉ thirteen) state
#+end_src

* [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]] ---Read and write to local storage

Let's combine writer and reader to get state: We can both read and write to data
by using functions ~Œµ ‚Üí (Œµ, Œ±)~ that read from an environment Œµ and result in a
new environment as well as a value.
- ~IO Œ± ‚âÖ State TheRealWorld Œ±~ ;-)
#+begin_src haskell :tangle terms_with_storage.hs
data State Œµ Œ± = S {run :: Œµ -> (Œµ, Œ±)}

push :: Monoid Œµ => Œµ -> State Œµ ()
push d = S $ \e -> (d <> e, ())

instance Functor (State Œµ) where
  fmap f (S g) = S $ \ e -> let (e', a) = g e in (e', f a)

instance Applicative (State Œµ) where
  pure a = S $ \e -> (e, a)
  (S sf) <*> (S g) = S $ \e -> let (e',  a) = g e
                                   (e'', f) = sf e' in (e'', f a)

instance Monad (State Œµ) where
  ma >>= f = join (pure f <*> ma)
    where join (S sf) = S $ \e -> let (e', S f) = sf e in f e'
#+end_src

A simple language with storage; a program's value is the value of its final store.
#+begin_src haskell :tangle terms_with_storage.hs
data Expr = Let String Expr Expr | Var String | Int Int | Div Expr Expr
           deriving Show

eval‚ÇÑ :: Expr -> State GlobalVars Int
eval‚ÇÑ (Var x) = S $ \e -> let r = x `valuefrom` e in ((x,r):e, r)
eval‚ÇÑ (Int x) = pure x
eval‚ÇÑ (Let x t body) = do n <- eval‚ÇÑ t
                          push [(x, n)] -- Applicative is NOT enough here!
                          eval‚ÇÑ body
eval‚ÇÑ (n `Div` d) = do t <- eval‚ÇÑ n; b <- eval‚ÇÑ d; pure (t `div` b)

thirteen = Let "x" (Int 1729)
             $ Let "y" (Int 133 `Div` Int 1)
                $ Var "x" `Div` Var "y"

-- run (eval‚ÇÑ thirteen) []
#+end_src

Exercise: Add to the oringal =Term= type a constructor =Rndm [Term]=, where =Rndm
[t‚ÇÅ, ‚Ä¶, t‚Çô]= denotes non-deterministicly choosing one of the terms ~t·µ¢~. Then write
an evaluator that considers all possible branches of a computation:
~eval‚ÇÖ : Term ‚Üí [Int]~.

If we want to mixin any of the features for our evaluators, we need to use ‚Äòmonad
transformers‚Äô since monads do not compose in general.

#+latex: \columnbreak
* Reads

- /Introduction to Functional Programming/ by Richard Bird
  - Assuming no programming, this book end by showing how to write a theorem
    prover powerful enough to prove many of laws scattered throughout the book.

- [[http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf][Monads for functional programming]] by Philip Wadler
  - This covers the ~eval·µ¢~ and more ^_^

- [[https://docs.racket-lang.org/heresy/monad-do.html][Comprehending Monads]] by Philip Wadler

- [[http://dev.stephendiehl.com/hask/][What I Wish I Knew When Learning Haskell]]

- [[https://wiki.haskell.org/Typeclassopedia][Typeclassopedia]] ---/The essentials of each type class are introduced, with
  examples, commentary, and extensive references for further reading./

- [[http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html][You Could Have Invented Monads! (And Maybe You Already Have.)]]

- [[http://learnyouahaskell.com/chapters][Learn You a Haskell for Great Good]] ---An accessible read with many examples, and drawings

- [[https://en.wikibooks.org/wiki/Haskell][The Haskell WikiBook]] ---Has four beginner's tracks and four advanced tracks

- [[https://alhassy.github.io/CatsCheatSheet/CheatSheet.pdf][Category Theory Cheat Sheet]] ---The ‚Äútheory of typed composition‚Äù:
  Products, Sums, Functors, Natural Transformations ^_^

- [[https://alhassy.github.io/AgdaCheatSheet/CheatSheet.pdf][Agda Cheat Sheet]] ---Agda is Haskell on steroids in that it you can invoke
  Haskell code and write proofs for it.

- LINQ for [[http://tomasp.net/blog/idioms-in-linq.aspx/#csidiomsl][applicatives]] and [[https://livebook.manning.com/book/real-world-functional-programming/chapter-12/28][monads]].
  - Monads ‚âà SQL/Linq ‚âà Comprehensions/Generators

#+latex: \ifnum\cheatsheetcols=1 \newpage \else \columnbreak \fi
