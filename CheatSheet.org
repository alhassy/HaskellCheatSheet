#+TITLE: Haskell CheatSheet
# +SUBTITLE: ---Reference Sheet for ‚ÄúWhat I'm Currently Learning‚Äù---
#+MACRO: blurb A reference sheet for the basics of the mind-expanding Haskell language (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
#+AUTHOR: [[https://alhassy.github.io/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+INCLUDE: CheatSheet/CheatSheetSetup.org
#+PROPERTY: header-args :results none
#+TODO: Todo | spacing LaTeX

* LaTeX Extra, Local, Setup  :ignore:

#+MACRO: newline @@latex: \newline@@

# Empty by default.
#+LATEX_HEADER: \def\cheatsheeturl{https://github.com/alhassy/HaskellCheatSheet}

# The following are the defaults & may be omitted.
#+LATEX_HEADER: \def\cheatsheetcols{2}
#+LATEX_HEADER: \landscapetrue
#+LATEX_HEADER: \def\cheatsheetitemsep{-0.5em}

# Example unicode declarations; see section ‚Äúunicode‚Äù below.
#+LATEX_HEADER: \newunicodechar{ùëª}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{‚âà}{\ensuremath{\approx}}
#+LATEX_HEADER: \newunicodechar{ùìç}{\ensuremath{x}}
#+LATEX_HEADER: \newunicodechar{Œ±}{\ensuremath{\alpha}}
#+LATEX_HEADER: \newunicodechar{Œ≤}{\ensuremath{\beta}}
#+LATEX_HEADER: \newunicodechar{Œµ}{\ensuremath{\epsilon}}
#+LATEX_HEADER: \newunicodechar{‚àÇ}{\ensuremath{\partial}}
#+LATEX_HEADER: \newunicodechar{‚äù}{\ensuremath{\ominus}}
#+LATEX_HEADER: \newunicodechar{‚Çã}{\ensuremath{_-}}

* COMMENT Contents :TOCish:QUOTE:ignore:
#+BEGIN_QUOTE
- [[#hello-home][Hello, Home!]]
- [[#pattern-matching][Pattern Matching]]
- [[#local-bindings][Local Bindings]]
- [[#operators][Operators]]
- [[#types][Types]]
- [[#tuples][Tuples]]
- [[#lists][Lists]]
  - [[#pattern-matching-on-lists][Pattern Matching on Lists]]
  - [[#common-methods-on-lists][Common Methods on Lists]]
- [[#list-design-patterns][List ‚ÄòDesign Patterns‚Äô]]
  - [[#map][Map]]
  - [[#filter][Filter]]
  - [[#fold][Fold]]
- [[#algebraic-data-types][Algebraic data types]]
- [[#typeclasses-and-overloading][*Typeclasses and overloading*]]
- [[#functor][Functor]]
  - [[#identity-axiom][Identity Axiom]]
  - [[#fusion-axiom][Fusion Axiom]]
  - [[#functors-do-not-necessarily-contain-anything][Functors do not necessarily ‚Äòcontain‚Äô anything]]
  - [[#misc-results-about-functors][Misc results about Functors]]
- [[#applicative----protecting-against-invalid-input][Applicative ---Protecting against invalid input]]
  - [[#axioms][Axioms]]
  - [[#canonical-form----liftn][Canonical Form -- =liftN=]]
  - [[#monoidal-presentation][Monoidal Presentation]]
- [[#do-notation][Do Notation]]
- [[#---monad----the-programmable-semicolon][*-- Monad ---‚Äúthe programmable semicolon‚Äù*]]
- [[#reads][Reads]]
#+END_QUOTE

* Hello, Home!

#+BEGIN_SRC haskell :tangle home.hs
main = do putStr "What's your name? "
          name <- getLine
          putStrLn ("It's 2020, " ++ name ++ "! Stay home, stay safe!")
#+END_SRC

* Pattern Matching

Functions can be defined using the usual ~if_then_else_~ construct, or
   as expressions /guarded/ by Boolean expressions as in mathematics, or
   by /pattern matching/ ---a form of ‚Äòsyntactic comparision‚Äô.

   #+BEGIN_SRC haskell
fact n = if n == 0 then 1 else n * fact (n - 1)

fact' n | n == 0 = 1
       | n != 0 = n * fact' (n - 1)

fact'' 0 = 1
fact'' n = n * fact'' (n - 1)
#+END_SRC

   The above definitions of the factorial function are all equal.

   Guards, as in the second version, are a form of ‚Äòmulti-branching conditional‚Äô.

   In the final version, when a call, say, ~fact 5~ happens we compare
   /syntactically/ whether ~5~ and the first pattern ~0~ are the same. They are not,
   so we consider the second case with the understanding that an identifier
   appearing in a pattern matches /any/ argument, so the second clause is used.

   Hence, when pattern matching is used, order of equations matters: If we
   declared the ~n~-pattern first, then the call ~fact 0~ would match it and we end
   up with ~0 * fact (-1)~, which is not what we want!

   If we simply defined the final ~fact~ using /only/ the first clause, then
   ~fact 1~ would crash with the error /Non-exhaustive patterns in function fact/.
   That is, we may define /partial functions/ by not considering all possible shapes of
   inputs.

   # Matches are tried in the order in which the equations are specfied, and the
   # first pattern that matches causes the corresponding equation to be selected.

   See also [[https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns][‚Äúview patterns‚Äù]].

* Local Bindings

An equation can be qualified by a ~where~ or ~let~ clause for defining values or
functions used only within an expression.

   #+BEGIN_SRC haskell
  ‚Ä¶e‚Ä¶e‚Ä¶e where e = ‚ÑØùìçùìÖùìá
‚âà let e = ‚ÑØùìçùìÖùìá in ‚Ä¶‚ÑØùìçùìÖùìá‚Ä¶‚ÑØùìçùìÖùìá‚Ä¶‚ÑØùìçùìÖùìá
#+END_SRC

It sometimes happens in functional programs that one clause of a function needs
/part of/ an argument, while another operators on the /whole/ argument. It it
tedious (and inefficient) to write out the structure of the complete argument
again when referring to it.
Use the ‚Äúas operator‚Äù ~@~ to label all or part of an argument, as in

#+BEGIN_SRC haskell
f label@(x:y:ys) = ‚ãØ
#+END_SRC

* Operators
Infix operators in Haskell must consist entiry of ‚Äòsymbols‚Äô such as ~&, ^, !, ‚Ä¶~
rather than alphanumeric characters. Hence, while addition, ~+~, is written infix,
integer division is written prefix with ~div~.

We can always use whatever fixity we like:
- If ~f~ is any /prefix/ binary function, then ~x `f` y~ is a valid /infix/ call.
- If ~‚äï~ is any /infix/ binary operator, then ~(‚äï) x y~ is a valid /prefix/ call.

It is common to fix one argument ahead of time, e.g., ~Œª x ‚Üí x + 1~ is the
successor operation and is written more tersely as ~(+1)~. More generally, ~(‚äïr) =
Œª x ‚Üí x ‚äï r~.

The usual arithmeic operations are ~+, /, *, -~ but ~%~ is used to make fractions.

The Boolean operations are ~==, /=, &&, ||~ for equality, discrepancy,
conjunction, and disjunction.

* Types

Type are inferred, but it is better to write them explicitly so that /you
communicate your intentions to the machine/. If you /think/ that expression ~e~ has
type ~œÑ~ then write ~e :: œÑ~ to /communicate/ that to the machine, which will silently
accept your claim or reject it loudly.

   | Type               | Name      | Example Value     |
   |--------------------+-----------+-------------------|
   | Small integers     | ~Int~       | ~42~                |
   | Unlimited integers | ~Integer~   | ~7376541234~        |
   | Reals              | ~Float~     | ~3.14~ and ~2 % 5~    |
   | Booleans           | ~Boolean~   | ~True~ and ~False~    |
   | Characters         | ~Char~      | ~'a'~ and ~'3'~       |
   | Strings            | ~String~    | ~"salam"~           |
   | Lists              | ~[Œ±]~       | ~[]~ or ~[x‚ÇÅ, ‚Ä¶, x‚Çô]~ |
   | Tuples             | ~(Œ±, Œ≤, Œ≥)~ | ~(x‚ÇÅ, x‚ÇÇ, x‚ÇÉ)~      |
   | Functions          | ~Œ± ‚Üí Œ≤~     | ~Œª x ‚Üí ‚ãØ~           |

/Polymorphism/ is the concept that allows one function to operate on different types.
   - A function whose type contains /variables/ is called a /polymorphic function/.
   - The simplest polymorphic function is ~id ‚à∑ a -> a~, defined by ~id x = x~.

* Tuples

*Tuples* ~(Œ±‚ÇÅ, ‚Ä¶, Œ±‚Çô)~ are types with values written ~(x‚ÇÅ, ‚Ä¶, x‚Çô)~ where each ~x·µ¢ ::
Œ±·µ¢~. The are a form of ‚Äòrecord‚Äô or ‚Äòproduct‚Äô type.

E.g., ~(True, 3, 'a') :: (Boolean, Int, Char)~.

Tuples are used to ‚Äúreturn multiple values‚Äù from a function.

Two useful functions on tuples of length 2 are:
   #+BEGIN_SRC haskell
fst :: (Œ±, Œ≤) ‚Üí Œ±
fst (x, y) = x

snd :: (Œ±, Œ≤) ‚Üí Œ≤
snd (x, y) = Œ≤
#+END_SRC

If in addition you ~import Control.Arrow~ then you may use:
   #+BEGIN_SRC haskell
first :: (Œ± ‚Üí œÑ) ‚Üí (Œ±, Œ≤) ‚Üí (œÑ, Œ≤)
first f (x, y) = (f x, y)

second :: (Œ≤ ‚Üí œÑ) ‚Üí (Œ±, Œ≤) ‚Üí (Œ±, œÑ)
second g (x, y) = (x, g y)

(***) :: (Œ± ‚Üí Œ±‚Ä≤) ‚Üí (Œ≤ ‚Üí Œ≤) ‚Üí (Œ±, Œ≤) ‚Üí (Œ±‚Ä≤, Œ≤‚Ä≤)
(f *** g) (x, y) = (f x, g y)

(&&&) :: (œÑ ‚Üí Œ±) ‚Üí (œÑ ‚Üí Œ≤) ‚Üí œÑ ‚Üí (Œ±, Œ≤)
(f &&& g) x = (f x, g x)
#+END_SRC

* Lists

*Lists* are sequences of items of the same type.
{{{newline}}}
If each ~x·µ¢ ‚à∑ Œ±~ then ~[x‚ÇÅ, ‚Ä¶, x‚Çô] ‚à∑ [Œ±]~.

   - The /empty list/ is ~[]~
   - We ‚Äúcons‚Äùtruct nonempty lists using ~(:) ‚à∑ Œ± ‚Üí [Œ±] ‚Üí [Œ±]~
   - Abbreviation: ~[x‚ÇÅ, ‚Ä¶, x‚Çô] = x‚ÇÅ ‚à∂ (x‚ÇÇ ‚à∂ (‚ãØ (x‚Çô ‚à∂ [])))~
   - /List comprehensions/: ~[f x | x <- xs, p x]~ is the list of elements
     ~f x~ where ~x~ is an element from list ~xs~ and ~x~ satisfies the property ~p~
     * E.g., ~[2 * x | x <- [2, 3, 4], x < 4] ‚âà [2 * 2, 2 * 3] ‚âà [4, 6]~
     # * /From ~xs~ we filter-out only those satisfying ~p~ then transform what's left with ~f~./
   - Shorthand notation for segments: ~u~ may be ommitted to yield /infinite lists/
     * ~[l .. u] = [l, l + 1, l + 2, ‚Ä¶, u]~.
       # - This notation also works on characters.
     * ~[a, b, .., u] = [a + i * step | i <- [0 .. u - a] ] where step = b - a~

*Strings* are just lists of characters: ~"c‚ÇÄc‚ÇÅ‚Ä¶c‚Çô" ‚âà ['c‚ÇÄ', ‚Ä¶, 'c‚Çô']~.
- Hence, all list methods work for strings.

** Pattern Matching on Lists
*Pattern matching on lists*
#+BEGIN_SRC haskell
prod []     = 1
prod (x:xs) = x * prod xs

fact n = prod [1 .. n]
#+END_SRC

If your function needs a case with a list of say, length 3, then you can match
directly on that /shape/ via ~[x, y, z]~ ---which is just an abbreviation for the
shape ~x:y:z:[]~. Likewise, if we want to consider lists of length /at least 3/ then
we match on the shape ~x:y:z:zs~. E.g., define the function that produces the
maximum of a non-empty list, or the function that removes adjacent duplicates
---both require the use of guards.

** Common Methods on Lists
#   -- Indexing
#  -- Gluing two lists together
#  -- Flattening a list of lists
#+BEGIN_SRC haskell
[x‚ÇÄ, ‚Ä¶, x‚Çô] !! i = x·µ¢
[x‚ÇÄ, ‚Ä¶, x‚Çô] ++ [y‚ÇÄ, ‚Ä¶, y‚Çò] = [x‚ÇÄ, ‚Ä¶, x‚Çô, y‚ÇÄ, ‚Ä¶, y‚Çò]
concat [xs‚ÇÄ, ‚Ä¶, xs‚Çô] = xs‚ÇÄ ++ ‚ãØ ++ xs‚Çô

{- Partial functions -}
head [x‚ÇÄ, ‚Ä¶, x‚Çô] = x‚ÇÄ
tail [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÅ, ‚Ä¶, x‚Çô]
init [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÄ, ‚Ä¶, x‚Çô‚Çã‚ÇÅ]
last [x‚ÇÄ, ‚Ä¶, x‚Çô] = x‚Çô

take k [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÄ, ‚Ä¶, x‚Çñ‚Çã‚ÇÅ]
drop k [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚Çñ, ‚Ä¶, x‚Çô]

sum     [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x‚ÇÄ + ‚ãØ + x‚Çô
prod    [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x‚ÇÄ * ‚ãØ * x‚Çô
reverse [x‚ÇÄ, ‚Ä¶, x‚Çô] =  [x‚Çô, ‚Ä¶, x‚ÇÄ]
elem x  [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x == x‚ÇÄ || ‚ãØ || x == x‚Çô

zip [x‚ÇÄ, ‚Ä¶, x‚Çô] [y‚ÇÄ, ‚Ä¶, y‚Çò]  = [(x‚ÇÄ, y‚ÇÄ), ‚Ä¶, (x‚Çñ, y‚Çñ)] where k = n `min` m
unzip [(x‚ÇÄ, y‚ÇÄ), ‚Ä¶, (x‚Çñ, y‚Çñ)] = ([x‚ÇÄ, ‚Ä¶, x‚Çñ], [y‚ÇÄ, ‚Ä¶, y‚Çñ])
#+END_SRC

[[https://en.wikipedia.org/wiki/Conjugacy_class][*Duality*]]: Let ~‚àÇf = reverse . f . reverse~, then ~init = ‚àÇ tail~ and {{{newline}}}
~take k = ‚àÇ (drop k)~; even ~pure . head = ‚àÇ (pure . last)~ where ~pure x = [x]~.

* List ‚ÄòDesign Patterns‚Äô

Many functions have the same ‚Äòform‚Äô or ‚Äòdesign pattern‚Äô, a fact which is
taken advantage of by defining /higher-order functions/ to factor out the
structural similarity of the individual functions.

** Map

 ~map f xs = [f x | x <- xs]~
     - Transform all elements of a list according to the function ~f~.

** Filter
 ~filter p xs = [x | x <- xs, p x]~
     - Keep only the elements of the list that satisfy the predicate ~p~.
     - ~takeWhile p xs~ ‚âà Take elements of ~xs~ that satisfy ~p~, but stop stop at
       the first element that does not satisfy ~p~.
     - ~dropWhile p xs~ ‚âà Drop all elements until you see one that does not satisfy
       the predicate.
     - ~xs = takeWhile p xs ++ dropWhile p xs~.

** Fold
 ~foldr (‚äï) e ‚âà Œª (x‚ÇÄ ‚à∂ (x‚ÇÅ ‚à∂ (‚Ä¶ ‚à∂ (x‚Çô : [])))) ‚Üí (x‚ÇÄ ‚äï (x‚ÇÅ ‚äï (‚Ä¶ ‚äï (x‚Çô ‚äï e))))~

- ‚ÄòSum‚Äô up the elements of the list, associating to the right.

- This function just replaces cons ~‚Äú‚à∂‚Äù~ and ~[]~ with ~‚äï~ and ~e~. That's all.
       * E.g., replacing ~:,[]~ with themselves does nothing: ~foldr (:) [] = id~.

/All functions on lists can be written as folds!/
#+BEGIN_SRC haskell
   h [] = e  ‚àß  h (x:xs) = x ‚äï h xs
‚â°  h = foldr (Œª x rec_call ‚Üí x ‚äï rec_call) e
#+END_SRC
+ Look at the two cases of a function and move them to the two
  first arguments of the fold.
  - ~map f = foldr (Œª x ys ‚Üí f x : ys) []~
  - ~filter p    = foldr (Œª x ys ‚Üí if (p x) then (x:ys) else ys) []~
  - ~takeWhile p = foldr (Œª x ys ‚Üí if (p x) then (x:ys) else []) []~
  # - E.g., ~dropWhile p = foldr (Œª x ys ‚Üí if (p x) then ys else (x:ys)) []~.
# #
You can also fold leftward, i.e., by associsting to the left:
#+BEGIN_SRC haskell
foldl (‚äï) e   ‚âà   Œª       (x‚ÇÄ : (x‚ÇÅ : (‚Ä¶ :  (x‚Çô : []))))
                  ‚Üí (((e ‚äï x‚ÇÄ) ‚äï x‚ÇÅ) ‚äï ‚Ä¶ ) ‚äï x‚Çô
#+END_SRC
Unless the operation ~‚äï~ is associative, the folds are generally different.
+ E.g., ~foldl (/) 1 [1..n] ‚âà 1 / n!~ where ~n ! = product [1..n]~.
+ E.g., ~-55 = foldl (-) 0 [1..10] ‚â† foldr (-) 0 [1..10] = -5~.

If ~h~ swaps arguments ---~h(x ‚äï y) = h y ‚äï h x~--- then ~h~ swaps folds:
 ~h . foldr (‚äï) e = foldl (‚äù) e‚Ä≤~ where ~e‚Ä≤ = h e~ and ~x ‚äù y = x ‚äï h y~.

E.g., ~foldl (-) 0 xs = - (foldr (+) 0 xs) = - (sum xs)~
and ~n ! = foldr (*) 1 [1..n] = 1 / foldl (/) 1 [1..n]~.

( Floating points are a leaky abstraction! )

* Algebraic data types

When we have ‚Äòpossible scenarios‚Äô, we can make a type to consider each option.
E.g., ~data Door = Open | Closed~ makes a new datatype with two different values.
Under the hood, ~Door~ could be implemented as integers and ~Open~ is 0 and ~Closed~
is 1; or any other implementation ---/all that matters/ is that we have a new
type, ~Door~, with two different values, ~Open~ and ~Closed~.

Usually, our scenarios contain a ‚Äòpayload‚Äô of additional information; e.g., ~data
Door2 = Open | Ajar Int | Closed~. Here, we have a new way to construct ~Door~
values, such as ~Ajar 10~ and ~Ajar 30~, that we could interpret as denoting how far
the door is open/. Under the hood, ~Door2~ could be implemented as pairs of
integers, with ~Open~ being ~(0,0)~, ~Ajar n~ being ~(1, n)~, and ~Closed~ being ~(2, 0)~
---i.e., as the pairs ‚Äú(value position, payload data)‚Äù. Unlike functions, a
value construction such as ~Ajar 10~ cannot be simplified any further; just as the
list value ~1:2:3:[]~ cannot be simplified any further. Remember, the
representation under the hood does not matter, what matters is that we have
three possible /construction forms/ of ~Door2~ values.

Languages, such as C, which do not support such an ‚Äúalgebraic‚Äù approach,
force you, the user, to actually choose a particular representation ---even
though, it does not matter, since we only want /a way to speak of/ ‚Äúdifferent
cases, with additional information‚Äù.

In general, we declare the following to get an ‚Äúenumerated type with payloads‚Äù.
#+BEGIN_SRC haskell
data D = C‚ÇÄ œÑ‚ÇÅ œÑ‚ÇÇ ‚Ä¶ œÑ‚Çò | C‚ÇÅ ‚ãØ | C‚Çô ‚ãØ deriving Show
#+END_SRC
There are =n= constructors ~C·µ¢~ that make /different/ values of type ~D~; e.g., ~C‚ÇÄ x‚ÇÅ x‚ÇÇ
‚Ä¶ x‚Çò~ is a ~D~-value whenever each ~x·µ¢~ is a ~œÑ·µ¢~-value. The ~‚Äúderiving Show‚Äù~ at the end
of the definition is necessary for user-defined types to make sure that values
of these types can be printed in a standard form.

We may now define functions on ~D~ by pattern matching on the possible ways to
/construct/ values for it; i.e., by considering the cases ~C·µ¢~.

In-fact, we could have written ~data D Œ±‚ÇÅ Œ±‚ÇÇ ‚Ä¶ Œ±‚Çñ = ‚ãØ~, so that we speak of ‚ÄúD
values /parameterised/ by types Œ±·µ¢‚Äù. E.g., ‚Äúlists whose elements are of type Œ±‚Äù is
defined by ~data List Œ± = Nil | Cons Œ± (List Œ±)~ and, for example, ~Cons 1 (Cons 2
Nil)~ is a value of ~List Int~, whereas ~Cons 'a' Nil~ is of type ~List Char~. ---The
~List~ type is missing the ~‚Äúderiving Show‚Äù~, see below for how to /mixin/ such a
feature.

* *Typeclasses and overloading*

/Overloading/ is using the same name to designate operations ‚Äúof the same nature‚Äù
on values of different types.

E.g., the ~show~ function converts its argument into a string; however, it is not
polymorphic: We cannot define ~show :: Œ± ‚Üí String~ with one definition since some
items, like functions or infinite datatypes, cannot be printed and so this is
not a valid type for the function ~show~.

Haskell solves this by having ~Show~ /typeclass/ whose /instance types/ ~Œ±~ each
implement a definition of the /class method/ ~show~. The type of ~show~ is written
~Show Œ± => Œ± -> String~: /Given an argument of type ~Œ±~, look in the global listing of
~Show~ instances, find the one for ~Œ±~, and use that;/ if ~Œ±~ has no ~Show~ instance,
then we have a type error. One says ‚Äúthe type variable ~Œ±~ has is /restricted/ to be
a ~Show~ instance‚Äù ---as indicated on the left side of the ~‚Äú=>‚Äù~ symbol.

E.g., for the ~List~ datatype we defined, we may declare it to be ‚Äòshowable‚Äô like
so:
#+begin_quote org
  #+BEGIN_SRC haskell -n 1
  instance Show a => Show (List a) where
    show Nil         = "Nope, nothing here"
    show (Cons x xs) = "Saw " ++ show x ++ ", then " ++ show xs
  #+END_SRC
#+end_quote
That is:
  1. /If ~a~ is showable, then ~List a~ is also showable./
  2. /Here's how to show ~Nil~ directly./
  3. /We show ~Cons x xs~ by using the ~show~ of ~a~ on ~x~, then recursively showing ~xs~./

|             | Common Typeclasses                                 |
|-------------+----------------------------------------------------|
| ~Show~        | Show elements as strings, ~show~                     |
| ~Read~        | How to read element values from strings, ~read~      |
| ~Eq~          | Compare elements for equality, ~==~                  |
| ~Num~         | Use literals ~0, 20, ‚Ä¶,~ and arithmetic ~+, *, -~      |
| ~Ord~         | Use comparison relations ~>, <, >=, <=~               |
| ~Enum~        | Types that can be listed, ~[start .. end]~           |
| ~Monoid~      | Types that model ‚Äò(untyped) composition‚Äô           |
| ~Functor~     | /Type formers/ that model effectful computation      |
| ~Applicative~ | Type formers that can sequence effects             |
| ~Monad~       | Type formers that let effects depend on each other |

The ~Ord~ typeclass is declared ~class Eq a => Ord a where ‚ãØ~, so that all ordered
types are necessarily also types with equality. One says ~Ord~ is a /subclass/ of
~Eq~; and since subclasses /inherit/ all functions of a class, we may always replace
~(Eq a, Ord a) => ‚ãØ~ by ~Ord a => ‚ãØ~.


You can of-course define your own typeclasses; e.g., the ~Num~ class in Haskell
could be defined as follows.
#+BEGIN_SRC haskell
class Num a where
  (+), (-), (*)       :: a -> a -> a
  negate, abs, signum :: a -> a
  fromInteger         :: Integer -> a
#+END_SRC

As shown earlier, Haskell provides a the ~deriving~ mechanism for making it easier
to define instances of typeclasses, such as ~Show, Read, Eq, Ord, Enum~. How?
Constructor names are printed and read as written as written in the ~data~
declaration, two values are equal if they are formed by the same construction,
one value is less than another if the constructor of the first is declared in
the ~data~ definition before the constructor of the second, and similarly for
listing elements out.
* Functor

/Functors are type formers that ‚Äúbehave‚Äù like collections: We can alter their/
/‚Äúelements‚Äù without messing with the ‚Äòcollection structure‚Äô or ‚Äòelement
positions‚Äô./ The well-behavedness constraints are called /the functor axioms/.
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (Œ± ‚Üí Œ≤) ‚Üí f Œ± ‚Üí f Œ≤

(<$>) = fmap {- An infix alias -}
#+END_SRC

The axioms cannot be checked by Haskell, so we can form instances that fail to
meet the implicit specifications ---two examples are below.

** Identity Axiom

*Identity Law*: ~fmap id = id~

/Doing no alteration to the contents of a collection does nothing to the collection./

This ensures that ‚Äúalterations don't needlessly mess with element values‚Äù
e.g., the following is not a functor since it does.
#+BEGIN_SRC haskell :tangle probably.hs
{- I probably have an item -}
data Probably a = Chance a Int

instance Functor Probably where
  fmap f (Chance x n) = Chance (f x) (n `div` 2)
#+END_SRC

** Fusion Axiom
*Fusion Law:* ~fmap f . fmap g = fmap (f . g)~

/Reaching into a collection and altering twice is the same as reaching in and
altering once./

This ensures that ‚Äúalterations don't needlessly mess with collection structure‚Äù;
e.g., the following is not a functor since it does.

#+BEGIN_SRC haskell :tangle pocket.hs
import Prelude hiding (Left, Right)

{- I have an item in my left or my right pocket -}
data Pocket a = Left a | Right a

instance Functor Pocket where
  fmap f (Left  x) = Right (f x)
  fmap f (Right x) = Left  (f x)
#+END_SRC

** Functors do not necessarily ‚Äòcontain‚Äô anything

It is important to note that functors model well-behaved container-like types, but of-course
the types do not actually need to contain anything at all! E.g., the following is a valid functor.
#+BEGIN_SRC haskell :tangle Liar.hs
{- ‚ÄúI totally have an Œ±-value, it's either here or there.‚Äù Lies! -}
data Liar Œ± = OverHere Int | OverThere Int

instance Functor Liar where
  fmap f (OverHere  n) = OverHere  n
  fmap f (OverThere n) = OverThere n
#+END_SRC
Notice that if we altered ~n~, say by dividing it by two, then we break the
identity law; and if we swap the constructors, then we break the fusion law.
Super neat stuff!

** Misc results about Functors

+ ~fmap f xs~ ‚âà /for each/ element ~x~ in the ‚Äòcollection‚Äô ~xs~, yield ~f x~.
+ Haskell can usually ~derive~ functor instances since they are [[http://archive.fo/U8xIY][unique]]: Only one
  possible definition of ~fmap~ will work.
  :Proof:
  Suppose we have a functor f and another function

foo :: (a -> b) -> f a -> f b

Then as a consequence of the free theorem for foo,
for any f :: a -> b and any g :: b -> c.

foo (g . f) = fmap g . foo f

In particular, if foo id = id, then

foo g = foo (g . id) = fmap g . foo id = fmap g . id = fmap g
  :End:
+ Reading the functor axioms left-to-right, they can be seen as /optimisation laws/
  that make a program faster by reducing work.
+ The two laws together give us: ~fmap (f‚ÇÅ . f‚ÇÇ . ‚ãØ . f‚Çô) = fmap f‚ÇÅ . ‚ãØ . fmap f‚Çô~
  for ~n ‚â• 0~.

*Naturality Theorems:* If ~p ‚à∑ f a ‚Üí g a~ for some /functors/ ~f~ and ~g~, {{{newline}}}
then ~fmap f . p = p . fmap f~ for any /function/ ~f~.

* Applicative ---Protecting against invalid input

/Applicatives are collection-like types that can apply collections of functions
to collections of elements./

In particular, /applicatives can fmap over multiple arguments/; e.g., if we try to
add ~Just 2~ and ~Just 3~, we find =(+) <$> Just 2 :: Maybe (Int ‚Üí Int)= and this is
not a function and so cannot be applied further to ~Just 3~ to get ~Just 5~.
We have both the function and the value wrapped up, so we need a way to apply
the former to the latter. The answer is ~(+) <$> Just 2 <*> Just 3~.

#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure   :: a -> f a
  (<*>)  :: f (a -> b) -> f a -> f b  {- ‚Äúapply‚Äù -}
  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  {-# MINIMAL pure, ((<*>) | liftA2) #-}

{- Apply associates to the left: p <*> q <*> r = (p <*> q) <*> r) -}
#+END_SRC

The method ~pure~ lets us inject values, to make ‚Äòsingleton collections‚Äô.

** Axioms
The applicative axioms ensure that apply behaves like usual functional application:

+ Identity: ~pure id <*> x = x~ ---c.f., ~id x = x~
+ Homomorphism: ~pure f <*> pure x = pure (f x)~ ---it really is function application
  on pure values!
  - Applying a non-effectful function to a non-effectful argument in an effectful
    context is the same as just applying the function to the argument and then
    injecting the result into the content.
+ Interchange: ~p <*> pure x = pure ($ x) <*> p~ ---c.f., ~f x = ($ x) f~
  - Functions ~f~ take ~x~ as input ‚âà Values ~x~ project functions ~f~ to particular values
  - When there is only one effectful component, then it does not matter whether
    we evaluate the function first or the argument first, there will still only be
    one effect.
  - Indeed, this is equivalent to the law: ~pure f <*> q = pure (flip ($)) <*> q <*> pure f~.

+ Composition: ~pure (.) <*> p <*> q <*> r = p <*> (q <*> r)~
  {{{newline}}} ---c.f., ~(f . g) . h = f . (g . h)~.

If we view ~f Œ±~ as an ‚Äúeffectful computation on Œ±‚Äù, then the above laws ensure
~pure~ creates an ‚Äúeffect free‚Äù context. E.g., if ~f Œ± = [Œ±]~ is considered
‚Äúnondeterminstic Œ±-values‚Äù, then ~pure~ just treats usual Œ±-values as
nondeterminstic but with no ambiguity, and ~fs <*> xs~ reads ‚Äúif we
nondeterminsticly have a choice ~f~ from ~fs~, and we nondeterminsticly an ~x~ from
~xs~, then we nondeterminsticly obtain ~f x~.‚Äù More concretely, if I'm given
randomly addition or multiplication along with the argument 3 and another
argument that could be 2, 4, or 6, then the result would be obtained by
considering all possible combinations: ~[(+), (*)] <*> pure 3 <*> [2, 4, 6] =
[5,7,9,6,12,18]~. The name ~‚Äú<*>‚Äù~ is suggestive of this ‚Äòcartesian product‚Äô nature.

Given a definition of apply, the definition of ~pure~ may be obtained
by unfolding the identity axiom.
# Given a definition of apply, the definition of ~pure~ is then unique.
# Proof?

Using these laws, we regain ~fmap~ thereby further cementing that applicatives
model ‚Äúcollections that can be functionally applied‚Äù: ~f <$> x = pure f <*> x~.
( Hence, every applicative is a functor whether we like it or not. )

** Todo Canonical Form -- =liftN=

Any expression built from the applicative methods can be transformed to the
canonical form of ‚Äúa pure function applied to effectful arguments‚Äù: ~pure f <*>
x‚ÇÅ <*> ‚ãØ <*> x‚Çô~ ---[[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][The laws]], as left-to-right rewrite rules, are the algorithm.
Notice that the canonical form generalises ~fmap~ to ~n~-arguments: Given ~f ‚à∑ Œ±‚ÇÅ ‚Üí ‚ãØ
‚Üí Œ±‚Çô ‚Üí Œ≤~ and ~x·µ¢ ‚à∑ f Œ±·µ¢~, we obtain an ~(f Œ≤)~-value. The case of ~n = 2~ is called
~liftA2~, and ~n = 1~ is just ~fmap~.

:More:
The ~ApplicativeDo~ extension permits a different
style for the canonical form:
#+BEGIN_SRC haskell
do v‚ÇÅ ‚Üê x‚ÇÅ
    ‚ãÆ
   v‚Çô ‚Üê x‚Çô
   pure (f v‚ÇÅ v‚ÇÇ ‚Ä¶ v‚Çô)
#+END_SRC
:End:
# For more details, see Applicative Programming with Effects, by Conor McBride
# and Ross Paterson.
** Monoidal Presentation

Notice that ~lift2A~ is essentially the cartesian product in the setting of lists,
or ~(<&>)~ below ---c.f., ~sequenceA :: Applicative f ‚áí [f a] ‚Üí f [a]~.

  #+BEGIN_SRC haskell
(<&>) :: f a ‚Üí f b ‚Üí f (a, b)   {- Not a standard name! -}
(<&>) = liftA2 (,)  -- i.e., p <&> q = (,) <$> p <*> q
#+END_SRC
This is a pairing operation with properties of ~(,)~ mirrored at the applicative level:
#+BEGIN_SRC haskell
{- Pure Pairing -} pure x <&> pure y = pure (x, y)
{- Naturality   -} (f &&& g) <$> (u <&> v) = (f <$> u) <&> (g <&> v)

{- Left Projection  -} fst <$> (u <&> pure ()) = u
{- Right Projection -} snd <$> (pure () <&> v)  = v
{- Associtivity     -} assocl <$> (u <&> (v <&> w)) = (u <&> v) <&> w
#+END_SRC
:PurePairing_Proof:
#+BEGIN_SRC haskell
  pure x <&> pure y
= (,) <$> pure x <*> pure y
= pure (,) <*> pure x <*> pure y
= pure (x,) <*> pure y
= pure (x,y)
#+END_SRC
:End:
The final three laws above suffice to prove the original applicative axioms, and so
we may define ~p <*> q = uncurry ($) <$> (p <&> q)~.
# Naturality, in the context of Haskell, is a free theorem.

* Do Notation
  Recall the ~map~ operation on lists, we could define it ourselves:
#+BEGIN_SRC haskell :tangle delme.hs
map' :: (Œ± -> Œ≤) -> [Œ±] -> [Œ≤]
map' f []     = []
map' f (x:xs) = let y  = f x
                    ys = map' f xs
                in  (y:ys)
#+END_SRC
If instead the altering function ~f~ returned effectful results,
then we could gather the results along with the effect:
#+BEGIN_SRC haskell :tangle delme1.hs
{-# LANGUAGE ApplicativeDo #-}

mapA :: Applicative f => (a -> f b) -> [a] -> f [b]
mapA f []     = pure []
mapA f (x:xs) = do y  <- f x
                   ys <- mapA f xs
                   pure (y:ys)
                {- ‚âà (:) <$> f x <*> mapA f xs -}
#+END_SRC

Applicative syntax can be a bit hard to write, whereas ~do~-notation is more
natural and reminiscent of the imperative style used in defining ~map'~ above. For
instance, the intuition that ~fs <*> ps~ is a cartesian product is clearer in
do-notation: ~fs <*> ps ‚âà do {f ‚Üê fs; x ‚Üê ps; pure (f x)}~ where the right side is
read /‚Äúfor-each f in fs, and each x in ps, compute f x‚Äù/.

# ‚ÄúDesugaring Haskell‚Äôs do-Notation into Applicative Operations‚Äù
[[https://dl.acm.org/doi/pdf/10.1145/3241625.2976007][In-general]], ~do {x‚ÇÅ ‚Üê p‚ÇÅ; ‚Ä¶; x‚Çô ‚Üê p‚Çô; pure e} ‚âà pure (Œª x‚ÇÅ ‚Ä¶ x‚Çô ‚Üí e) <*> p‚ÇÅ <*> ‚ãØ
<*> p‚Çô~ *provided* ~p·µ¢~ does not mention ~x‚±º~ for ~j < i~; but =e= may refer to all ~x·µ¢~. If
any ~p·µ¢~ mentions an earlier ~x‚±º~, then we could not translate the ~do~-notation into
an applicative expression.

If ~do {x ‚Üê p; y ‚Üê qx; pure e}~ has ~qx~ being an expression *depending* on ~x~,
then we could say this is an abbreviation for ~(Œª x -> (Œª y ‚Üí e) <$> qx) <$> p~
but this is of type ~f (f Œ≤))~. Hence, to allow later computations to depend
on earlier computations, we need a method ~join :: f (f Œ±) ‚Üí Œ±~ with which
we define ~do {x ‚Üê p; y ‚Üê qx; pure e} ‚âà join $ ~(Œª x -> (Œª y ‚Üí e) <$> qx) <$> p~.

Applicatives with a ~join~ are called monads and they give us a *‚Äúprogrammable
semicolon‚Äù*. Since later items may depend on earlier ones, ~do {x ‚Üê p; y ‚Üê q;
pure e}~ could be read /‚Äúlet x be the value of computation p, let y be the value
of computation q, then combine the values via expression e‚Äù/. Depending on how
~<*>~ is implemented, such ‚Äòlet declarations‚Äô could short-circuit (~Maybe~) or be
nondeterministic (~List~) or have other effects such as altering state.

As the ~do~-notation clearly shows, the primary difference between =Monad= and
=Applicative= is that =Monad= allows dependencies on previous results, whereas
=Applicative= does not.

:TypeChecking:
#+BEGIN_SRC haskell :tangle delme_0.hs
p‚ÇÅ :: Applicative f => f Œ±
p‚ÇÅ = undefined

p‚ÇÇ :: Applicative f => Œ± -> f Œ≤
p‚ÇÇ = undefined

data C = C

e :: Œ± -> Œ≤ -> C
e = undefined

this :: Applicative f => f (f C)
-- this = e <$> p‚ÇÅ <*> undefined
this = (\ x‚ÇÅ -> e x‚ÇÅ <$> p‚ÇÇ x‚ÇÅ) <$> p‚ÇÅ
#+END_SRC
:End:

* Todo *-- Monad ---‚Äúthe programmable semicolon‚Äù*

Coming soon ... See end of week of April 3rd, 2020 ...

* COMMENT Comparing Monad and Applicative

[[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][Intuitively]], the ~(>>=) :: m Œ± ‚Üí (Œ± ‚Üí m Œ≤) ‚Üí m Œ≤~ of a monad ~m~ allows the value
returned by one computation to influence the choice of another, whereas ~(<*>)~
keeps the structure of a computation fixed, just sequencing the effects. For
example, in ~wx >>= Œª x ‚Üí if x then wy else wz~ the value of ~wx~ will choose between
the /computations/ ~wy~ and ~wz~, performing only one, whilst ~(Œª x y z ‚Üí if x then y
else z) <$> wx <*> wy <*> wz~ performs the effects of all three computations,
using the value of ~wx~ to choose only between the /values/ of ~wy~ and ~wz~. For
example, if ~f Œ± = m Œ± = [Œ±]~ and ~wx = [True], wz = []~ then the applicative
expression is ~[]~ since the ‚Äòelse‚Äô computation ‚Äòfails‚Äô, whereas the monadic
expression is ~wy~. [[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][However]], whereas monads abort on the first ‚Äòfailure‚Äô, /with the
applicative interface we can continue in the face of errors./
#+BEGIN_SRC haskell
f :: Applicative f => f Bool -> f b -> f b -> f b
f xs ys zs = (\x y z -> if x then y else z) <$> xs <*> ys <*> zs

> f [True] [1..10] []
[]

m xs ys zs = xs >>= \x -> if x then ys else zs

> m [True] [1..10] []
[1,2,3,4,5,6,7,8,9,10]
#+END_SRC

Hence, properties of applicatives ---such as length--- can be determined
statically just by looking at the inputs, whereas monadic expressions can change
the collection structure ---and its properties--- since they can look at
intermediate results to decide what to do next.

Applicatives sequence independent effects, whereas monads allow effects to
depend on each other.

* Reads

+ [[http://dev.stephendiehl.com/hask/][What I Wish I Knew When Learning Haskell]]
+ [[https://wiki.haskell.org/Typeclassopedia][Typeclassopedia]] ---/The essentials of each type class are introduced, with
   examples, commentary, and extensive references for further reading./

 :TODO:
 http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows-and-idioms
 How arrows fit into the functor/applicative/monad hierarchy? See Idioms are
 oblivious, arrows are meticulous, monads are promiscuous by Sam Lindley, Philip
 Wadler, Jeremy Yallop. MSFP 2008. (They call applicative functors idioms.) The
 abstract:

 We revisit the connection between three notions of computation: Moggi's monads,
 Hughes's arrows and McBride and Paterson's idioms (also called applicative
 functors). We show that idioms are equivalent to arrows that satisfy the type
 isomorphism A ~> B = 1 ~> (A -> B) and that monads are equivalent to arrows that
 satisfy the type isomorphism A ~> B = A -> (1 ~> B). Further, idioms embed into
 arrows and arrows embed into monads.
 :END:

* COMMENT What if I want ~N~ columns? Or non-landscape? Or multiple formats?


Press ~C-c C-c~ on the following incantation to produce a single column portrait of the cheat sheet.
#+name: make-portrait
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: CheatSheet_Portrait.pdf
     ,#+LATEX_HEADER_EXTRA: \\landscapefalse \\def\\cheatsheetcols{1}
     ,#+INCLUDE: CheatSheet.org
    ")

    (let ((org-export-use-babel nil))
      (org-mode)
      (org-latex-export-to-pdf)
      )
)
#+END_SRC

* spacing COMMENT break                                                      :ignore:
#+latex: \columnbreak
* COMMENT Basic Equational Support

# Basic name-formula equational support.

~\eqn{name}{formula}~
yields a displayed equation with ~formula~ left aligned and ~name~ right aligned:

#+latex: \vspace{-0.7em}
\eqn{name}{formula}
#+BEGIN_EXPORT latex
\eqn{Functoriality}{
  F(f_0 \circ \cdots \circ f_{n-1}) \;=\; F\, f_0 \circ \cdots \circ F\, f_{n-1}
  }
#+END_EXPORT

Moreover, we can refer to such a formula by invoking ~\ref{name}~ ---e.g., \ref{Functoriality} and \ref{name}.
However, if ~name~ involves unicode symbols, then this may cause problems.

See the [[https://github.com/alhassy/CatsCheatSheet][CatsCheatSheet]] for examples of this kind.

We may also use [[https://github.com/jkitchin/org-ref][org-ref]] style references, as in ~eqref:name~. However, org-ref may warn that
no context for the reference is found ---that's okay.

+ eqref   :: Parenthesised reference: eqref:name
+ autoref :: Prefix reference with type: autoref:name
+ nameref :: The name of the section that contains this reference: nameref:name

:MultipleEquationsExample:

preamble words here --below comes from CatsCheatSheet--

#+BEGIN_EXPORT latex
\begineqns

\eqn{$\langle\rangle$-Type}{f : C ‚Üí A \lands g : C ‚Üí B \impliesS ‚ü®f, g‚ü© : C ‚Üí A √ó B}

\eqn{$\langle\rangle$-Char}{ \fst ‚àò x = f \lands \snd ‚àò x = g \equivS x = ‚ü®f, g‚ü© }

\eqn{$\langle\rangle$-Cancellation; $\langle\rangle$-Self}{ \fst ‚àò ‚ü®f, g‚ü© = f \landS \snd ‚àò ‚ü®f, g‚ü© = g}

\eqn{$\langle\rangle$-Id}{ ‚ü®\fst, \snd‚ü© = \Id}

\eqn{$\langle\rangle$-Unique}{ \fst ‚àò x = \fst ‚àò y  \lands \snd ‚àò x = \snd ‚àò y \impliesS x = y}

\eqn{$\langle\rangle$-Fusion}{ ‚ü®f , g‚ü© ‚àò x = ‚ü®f ‚àò x , g ‚àò x‚ü© }

\eqn{$\langle\rangle$-Functor-Dist}{F \, ‚ü®f, g‚ü©_ùíû = ‚ü®F \, f , F \, g‚ü©_ùíü \qquad\text{ where } F : ùíû ‚Üí ùíü}

\endeqns
#+END_EXPORT

#+latex: \room
#+latex: \room

postamble words here

:End:

#+latex: \vspace{-3em}
* COMMENT Parallel Environment

Cheat sheets should not waste space, so the setup provides
a ~parallel~ LaTeX enviornment that takes an optional parameter
indicating how many columns are desired ---two by default.
Importantly, we use this environment as if it were any normal org-block:
#
#+begin_parallel org
#+BEGIN_EXAMPLE org :tangle no
,#‚∏≤
,#+begin_parallel org
???content here???
,#+end_parallel
#+END_EXAMPLE

The initial new line is important, otherwise the parallel environment
occurs in-line, which may not be the intended behaviour.
#+end_parallel

The column break is automatic, but as
this is sugar for a ~minipage~ containing a ~multicolum~ we can force a column
separation with ~\columnbreak~.
# This command, in Org, necessities newlines between
# the items being separated.

~parallelNB~ produces a side-by-side rendition with ‚ÄòN‚Äôo ‚ÄòB‚Äôar:
#
#+begin_parallelNB org
left \newline left \newline left

#+latex: \columnbreak
right \newline right \newline right
#+end_parallelNB

Here is an example with four columns:
#
#+ATTR_LATEX: :options [4]
#+begin_parallel org
left \newline left \newline left

#+latex: \columnbreak
middle \newline middle \newline middle

#+latex: \columnbreak
middle \newline middle \newline middle

#+latex: \columnbreak
right \newline right \newline right
#+end_parallel

Here is an example with three columns and ‚Äòn‚Äôo ‚Äòb‚Äôar:
#
#+begin_parallel3NB org
left \newline left \newline left

#+latex: \columnbreak
middle \newline middle \newline middle

#+latex: \columnbreak
right \newline right \newline right
#+end_parallel3NB

#+latex: \vfill {\color{white}.}

* spacing COMMENT break :accomodating_multiple_formats:ignore:

#+LATEX: \ifnum\cheatsheetcols=1 \newpage \else \columnbreak \fi

* COMMENT Making ~README.org~

  Evaluate the following source block with ~C-c C-c~
  to produce a ~README~ file.

  # :'( For some reason using {{{title}}} below would not work.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org
     # HTML: <h1> HaskellCheatSheet </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

     :Hide:
     This project is to contain a listing of common results in X Theory.

     ,*The repo contains other articles I've written on X Theory;*
     ,*which may be read in a blog-format at:*
     https://alhassy.github.io/blog/categories/#Xtheory
     :End:

     #+begin_quote
    ,*The listing sheet, as PDF, can be found
     [[https://alhassy.github.io/HaskellCheatSheet/CheatSheet.pdf][here]]*,
     or as a [[https://alhassy.github.io/HaskellCheatSheet/CheatSheet_Portrait.pdf][single column portrait]],
     while below is an unruly html rendition.
     #+end_quote

     # Markdown links: [title](target)

     This reference sheet is built from a
     [[https://github.com/alhassy/CheatSheet][CheatSheets with Org-mode]]
     system.

     #+html: <p align=\"center\"><a href=\"https://www.haskell.org/\"><img src=\"https://img.shields.io/badge/GHC-8.6.4-b48ead.svg?style=plastic\"/></a>

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      ; (org-md-export-to-markdown)
      ; (package-install 'toc-org)
      (toc-org-mode)
      (toc-org-insert-toc)
      (org-org-export-to-org)
      )
)
#+END_SRC


Note that the ~blurb~ macro is defined by the user, to provide a terse description of the project.
   - Think the one-line statement at the top of a github repo page.

#    The ~d:nil~ ensures the ‚Äòdrawer‚Äô ~:Hide: ‚ãØ :End:~ is not exported; it's there for me
#    as a reminder.
