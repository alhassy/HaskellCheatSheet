#+TITLE: Haskell CheatSheet
# +SUBTITLE: ---Reference Sheet for ‚ÄúWhat I'm Currently Learning‚Äù---
#+MACRO: blurb A reference sheet for the basics of the mind-expanding Haskell language (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
#+AUTHOR: [[https://alhassy.github.io/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+INCLUDE: CheatSheet/CheatSheetSetup.org
#+PROPERTY: header-args :results none
#+TODO: Todo | spacing LaTeX

* LaTeX Extra, Local, Setup  :ignore:

#+MACRO: newline @@latex: \newline@@

# Empty by default.
#+LATEX_HEADER: \def\cheatsheeturl{https://github.com/alhassy/HaskellCheatSheet}

# The following are the defaults & may be omitted.
#+LATEX_HEADER: \def\cheatsheetcols{2}
#+LATEX_HEADER: \landscapetrue
#+LATEX_HEADER: \def\cheatsheetitemsep{-0.5em}

# Example unicode declarations; see section ‚Äúunicode‚Äù below.
#+LATEX_HEADER: \newunicodechar{ùëª}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{‚âà}{\ensuremath{\approx}}
#+LATEX_HEADER: \newunicodechar{ùìç}{\ensuremath{x}}
#+LATEX_HEADER: \newunicodechar{Œ±}{\ensuremath{\alpha}}
#+LATEX_HEADER: \newunicodechar{Œ≤}{\ensuremath{\beta}}
#+LATEX_HEADER: \newunicodechar{Œµ}{\ensuremath{\epsilon}}
#+LATEX_HEADER: \newunicodechar{‚àÇ}{\ensuremath{\partial}}
#+LATEX_HEADER: \newunicodechar{‚äù}{\ensuremath{\ominus}}
#+LATEX_HEADER: \newunicodechar{‚Çã}{\ensuremath{_-}}
#+LATEX_HEADER: \newunicodechar{‚ü∂}{\ensuremath{\rightarrow}}
#+LATEX_HEADER: \newunicodechar{‚àâ}{\ensuremath{\not\in}}
#+LATEX_HEADER: \newunicodechar{‚ÄØ}{\ensuremath{\;\;}}

* Contents :TOCish:QUOTE:ignore:
#+BEGIN_QUOTE
- [[#hello-home][Hello, Home!]]
- [[#pattern-matching][Pattern Matching]]
- [[#local-bindings][Local Bindings]]
- [[#operators][Operators]]
- [[#types][Types]]
- [[#tuples][Tuples]]
- [[#lists][Lists]]
  - [[#pattern-matching-on-lists][Pattern Matching on Lists]]
  - [[#common-methods-on-lists][Common Methods on Lists]]
- [[#list-design-patterns][List ‚ÄòDesign Patterns‚Äô]]
  - [[#map][Map]]
  - [[#filter][Filter]]
  - [[#fold][Fold]]
- [[#algebraic-data-types][Algebraic data types]]
- [[#typeclasses-and-overloading][Typeclasses and overloading]]
- [[#functor][Functor]]
  - [[#identity-axiom][Identity Axiom]]
  - [[#fusion-axiom][Fusion Axiom]]
  - [[#functors-do-not-necessarily-contain-anything][Functors do not necessarily ‚Äòcontain‚Äô anything]]
  - [[#misc-results-about-functors][Misc results about Functors]]
- [[#functor-examples][Functor Examples]]
- [[#applicative][Applicative]]
  - [[#axioms][Axioms]]
  - [[#canonical-form----liftn][Canonical Form -- =liftN=]]
  - [[#monoidal-presentation][Monoidal Presentation]]
- [[#applicative-examples][Applicative Examples]]
- [[#do-notation----subtle-difference-between-applicatives-and-monads][~Do~-Notation ---Subtle difference between applicatives and monads]]
  - [[#do-notation-with-tuples-and-functions][Do-notation with tuples and functions]]
- [[#formal-definition-of-do-notation][Formal Definition of ~Do~-Notation]]
- [[#monad-laws][Monad Laws]]
- [[#monad-examples][Monad Examples]]
- [[#running-example----a-simple-arithmetic-language][Running Example ---A Simple Arithmetic Language]]
- [[#maybe----possibly-failing-computations][Maybe ---Possibly Failing Computations]]
- [[#writer----logging-information-as-we-compute][Writer ---Logging Information as we Compute]]
- [[#reader----accessing-global-read-only-data][Reader ---Accessing ‚ÄòGlobal, read-only, data‚Äô]]
- [[#state----read-and-write-to-local-storage][State ---Read and write to local storage]]
- [[#reads][Reads]]
#+END_QUOTE

* Hello, Home!

#+BEGIN_SRC haskell :tangle home.hs
main = do putStr "What's your name? "
          name <- getLine
          putStrLn ("It's 2020, " ++ name ++ "! Stay home, stay safe!")
#+END_SRC

* Pattern Matching

Functions can be defined using the usual ~if_then_else_~ construct, or
   as expressions /guarded/ by Boolean expressions as in mathematics, or
   by /pattern matching/ ---a form of ‚Äòsyntactic comparision‚Äô.

   #+BEGIN_SRC haskell
fact n = if n == 0 then 1 else n * fact (n - 1)

fact' n | n == 0 = 1
       | n != 0 = n * fact' (n - 1)

fact'' 0 = 1
fact'' n = n * fact'' (n - 1)
#+END_SRC

   The above definitions of the factorial function are all equal.

   Guards, as in the second version, are a form of ‚Äòmulti-branching conditional‚Äô.

   In the final version, when a call, say, ~fact 5~ happens we compare
   /syntactically/ whether ~5~ and the first pattern ~0~ are the same. They are not,
   so we consider the second case with the understanding that an identifier
   appearing in a pattern matches /any/ argument, so the second clause is used.

   Hence, when pattern matching is used, order of equations matters: If we
   declared the ~n~-pattern first, then the call ~fact 0~ would match it and we end
   up with ~0 * fact (-1)~, which is not what we want!

   If we simply defined the final ~fact~ using /only/ the first clause, then
   ~fact 1~ would crash with the error /Non-exhaustive patterns in function fact/.
   That is, we may define /partial functions/ by not considering all possible shapes of
   inputs.

   # Matches are tried in the order in which the equations are specfied, and the
   # first pattern that matches causes the corresponding equation to be selected.

   See also [[https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns][‚Äúview patterns‚Äù]].

* Local Bindings

An equation can be qualified by a ~where~ or ~let~ clause for defining values or
functions used only within an expression.

   #+BEGIN_SRC haskell
  ‚Ä¶e‚Ä¶e‚Ä¶e where e = ‚ÑØùìçùìÖùìá
‚âà let e = ‚ÑØùìçùìÖùìá in ‚Ä¶‚ÑØùìçùìÖùìá‚Ä¶‚ÑØùìçùìÖùìá‚Ä¶‚ÑØùìçùìÖùìá
#+END_SRC

It sometimes happens in functional programs that one clause of a function needs
/part of/ an argument, while another operators on the /whole/ argument. It it
tedious (and inefficient) to write out the structure of the complete argument
again when referring to it.
Use the ‚Äúas operator‚Äù ~@~ to label all or part of an argument, as in

#+BEGIN_SRC haskell
f label@(x:y:ys) = ‚ãØ
#+END_SRC

* Operators
Infix operators in Haskell must consist entiry of ‚Äòsymbols‚Äô such as ~&, ^, !, ‚Ä¶~
rather than alphanumeric characters. Hence, while addition, ~+~, is written infix,
integer division is written prefix with ~div~.

We can always use whatever fixity we like:
- If ~f~ is any /prefix/ binary function, then ~x `f` y~ is a valid /infix/ call.
- If ~‚äï~ is any /infix/ binary operator, then ~(‚äï) x y~ is a valid /prefix/ call.

It is common to fix one argument ahead of time, e.g., ~Œª x ‚Üí x + 1~ is the
successor operation and is written more tersely as ~(+1)~. More generally, ~(‚äïr) =
Œª x ‚Üí x ‚äï r~.

The usual arithmeic operations are ~+, /, *, -~ but ~%~ is used to make fractions.

The Boolean operations are ~==, /=, &&, ||~ for equality, discrepancy,
conjunction, and disjunction.

* Types

Type are inferred, but it is better to write them explicitly so that /you
communicate your intentions to the machine/. If you /think/ that expression ~e~ has
type ~œÑ~ then write ~e :: œÑ~ to /communicate/ that to the machine, which will silently
accept your claim or reject it loudly.

   | Type               | Name      | Example Value     |
   |--------------------+-----------+-------------------|
   | Small integers     | ~Int~       | ~42~                |
   | Unlimited integers | ~Integer~   | ~7376541234~        |
   | Reals              | ~Float~     | ~3.14~ and ~2 % 5~    |
   | Booleans           | ~Boolean~   | ~True~ and ~False~    |
   | Characters         | ~Char~      | ~'a'~ and ~'3'~       |
   | Strings            | ~String~    | ~"salam"~           |
   | Lists              | ~[Œ±]~       | ~[]~ or ~[x‚ÇÅ, ‚Ä¶, x‚Çô]~ |
   | Tuples             | ~(Œ±, Œ≤, Œ≥)~ | ~(x‚ÇÅ, x‚ÇÇ, x‚ÇÉ)~      |
   | Functions          | ~Œ± ‚Üí Œ≤~     | ~Œª x ‚Üí ‚ãØ~           |

/Polymorphism/ is the concept that allows one function to operate on different types.
   - A function whose type contains /variables/ is called a /polymorphic function/.
   - The simplest polymorphic function is ~id ‚à∑ a -> a~, defined by ~id x = x~.

* Tuples

*Tuples* ~(Œ±‚ÇÅ, ‚Ä¶, Œ±‚Çô)~ are types with values written ~(x‚ÇÅ, ‚Ä¶, x‚Çô)~ {{{newline}}} where
each ~x·µ¢ :: Œ±·µ¢~. The are a form of ‚Äòrecord‚Äô or ‚Äòproduct‚Äô type.

E.g., ~(True, 3, 'a') :: (Boolean, Int, Char)~.

Tuples are used to ‚Äúreturn multiple values‚Äù from a function.

Two useful functions on tuples of length 2 are:
   #+BEGIN_SRC haskell
fst :: (Œ±, Œ≤) ‚Üí Œ±
fst (x, y) = x

snd :: (Œ±, Œ≤) ‚Üí Œ≤
snd (x, y) = Œ≤
#+END_SRC

If in addition you ~import Control.Arrow~ then you may use:
   #+BEGIN_SRC haskell
first :: (Œ± ‚Üí œÑ) ‚Üí (Œ±, Œ≤) ‚Üí (œÑ, Œ≤)
first f (x, y) = (f x, y)

second :: (Œ≤ ‚Üí œÑ) ‚Üí (Œ±, Œ≤) ‚Üí (Œ±, œÑ)
second g (x, y) = (x, g y)

(***) :: (Œ± ‚Üí Œ±‚Ä≤) ‚Üí (Œ≤ ‚Üí Œ≤) ‚Üí (Œ±, Œ≤) ‚Üí (Œ±‚Ä≤, Œ≤‚Ä≤)
(f *** g) (x, y) = (f x, g y)

(&&&) :: (œÑ ‚Üí Œ±) ‚Üí (œÑ ‚Üí Œ≤) ‚Üí œÑ ‚Üí (Œ±, Œ≤)
(f &&& g) x = (f x, g x)
#+END_SRC

* Lists

*Lists* are sequences of items of the same type.
{{{newline}}}
If each ~x·µ¢ ‚à∑ Œ±~ then ~[x‚ÇÅ, ‚Ä¶, x‚Çô] ‚à∑ [Œ±]~.

Lists are useful for functions that want to ‚Äònon-deterministicly‚Äô return a
value: {{{newline}}} They return a list of all possible values.

   - The /empty list/ is ~[]~
   - We ‚Äúcons‚Äùtruct nonempty lists using ~(:) ‚à∑ Œ± ‚Üí [Œ±] ‚Üí [Œ±]~
   - Abbreviation: ~[x‚ÇÅ, ‚Ä¶, x‚Çô] = x‚ÇÅ ‚à∂ (x‚ÇÇ ‚à∂ (‚ãØ (x‚Çô ‚à∂ [])))~
   - /List comprehensions/: ~[f x | x <- xs, p x]~ is the list of elements
     ~f x~ where ~x~ is an element from list ~xs~ and ~x~ satisfies the property ~p~
     * E.g., ~[2 * x | x <- [2, 3, 4], x < 4] ‚âà [2 * 2, 2 * 3] ‚âà [4, 6]~
     # * /From ~xs~ we filter-out only those satisfying ~p~ then transform what's left with ~f~./
   - Shorthand notation for segments: ~u~ may be ommitted to yield /infinite lists/
     * ~[l .. u] = [l, l + 1, l + 2, ‚Ä¶, u]~.
       # - This notation also works on characters.
     * ~[a, b, .., u] = [a + i * step | i <- [0 .. u - a] ] where step = b - a~

*Strings* are just lists of characters: ~"c‚ÇÄc‚ÇÅ‚Ä¶c‚Çô" ‚âà ['c‚ÇÄ', ‚Ä¶, 'c‚Çô']~.
- Hence, all list methods work for strings.

** Pattern Matching on Lists
*Pattern matching on lists*
#+BEGIN_SRC haskell
prod []     = 1
prod (x:xs) = x * prod xs

fact n = prod [1 .. n]
#+END_SRC

If your function needs a case with a list of say, length 3, then you can match
directly on that /shape/ via ~[x, y, z]~ ---which is just an abbreviation for the
shape ~x:y:z:[]~. Likewise, if we want to consider lists of length /at least 3/ then
we match on the shape ~x:y:z:zs~. E.g., define the function that produces the
maximum of a non-empty list, or the function that removes adjacent duplicates
---both require the use of guards.

** Common Methods on Lists
#   -- Indexing
#  -- Gluing two lists together
#  -- Flattening a list of lists
#+BEGIN_SRC haskell
[x‚ÇÄ, ‚Ä¶, x‚Çô] !! i = x·µ¢
[x‚ÇÄ, ‚Ä¶, x‚Çô] ++ [y‚ÇÄ, ‚Ä¶, y‚Çò] = [x‚ÇÄ, ‚Ä¶, x‚Çô, y‚ÇÄ, ‚Ä¶, y‚Çò]
concat [xs‚ÇÄ, ‚Ä¶, xs‚Çô] = xs‚ÇÄ ++ ‚ãØ ++ xs‚Çô

{- Partial functions -}
head [x‚ÇÄ, ‚Ä¶, x‚Çô] = x‚ÇÄ
tail [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÅ, ‚Ä¶, x‚Çô]
init [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÄ, ‚Ä¶, x‚Çô‚Çã‚ÇÅ]
last [x‚ÇÄ, ‚Ä¶, x‚Çô] = x‚Çô

take k [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚ÇÄ, ‚Ä¶, x‚Çñ‚Çã‚ÇÅ]
drop k [x‚ÇÄ, ‚Ä¶, x‚Çô] = [x‚Çñ, ‚Ä¶, x‚Çô]

sum     [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x‚ÇÄ + ‚ãØ + x‚Çô
prod    [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x‚ÇÄ * ‚ãØ * x‚Çô
reverse [x‚ÇÄ, ‚Ä¶, x‚Çô] =  [x‚Çô, ‚Ä¶, x‚ÇÄ]
elem x  [x‚ÇÄ, ‚Ä¶, x‚Çô] =  x == x‚ÇÄ || ‚ãØ || x == x‚Çô

zip [x‚ÇÄ, ‚Ä¶, x‚Çô] [y‚ÇÄ, ‚Ä¶, y‚Çò]  = [(x‚ÇÄ, y‚ÇÄ), ‚Ä¶, (x‚Çñ, y‚Çñ)] where k = n `min` m
unzip [(x‚ÇÄ, y‚ÇÄ), ‚Ä¶, (x‚Çñ, y‚Çñ)] = ([x‚ÇÄ, ‚Ä¶, x‚Çñ], [y‚ÇÄ, ‚Ä¶, y‚Çñ])
#+END_SRC

[[https://en.wikipedia.org/wiki/Conjugacy_class][*Duality*]]: Let ~‚àÇf = reverse . f . reverse~, then ~init = ‚àÇ tail~ and {{{newline}}}
~take k = ‚àÇ (drop k)~; even ~pure . head = ‚àÇ (pure . last)~ where ~pure x = [x]~.

* List ‚ÄòDesign Patterns‚Äô

Many functions have the same ‚Äòform‚Äô or ‚Äòdesign pattern‚Äô, a fact which is
taken advantage of by defining /higher-order functions/ to factor out the
structural similarity of the individual functions.

** Map

 ~map f xs = [f x | x <- xs]~
     - Transform all elements of a list according to the function ~f~.

** Filter
 ~filter p xs = [x | x <- xs, p x]~
     - Keep only the elements of the list that satisfy the predicate ~p~.
     - ~takeWhile p xs~ ‚âà Take elements of ~xs~ that satisfy ~p~, but stop stop at
       the first element that does not satisfy ~p~.
     - ~dropWhile p xs~ ‚âà Drop all elements until you see one that does not satisfy
       the predicate.
     - ~xs = takeWhile p xs ++ dropWhile p xs~.

** Fold
Right-folds let us ‚Äòsum‚Äô up the elements of the list, associating to the right.
#+BEGIN_SRC haskell
foldr (‚äï) e ‚âà Œª (x‚ÇÄ : (x‚ÇÅ : (‚Ä¶ : (x‚Çô : []))))
              ‚Üí (x‚ÇÄ ‚äï (x‚ÇÅ ‚äï (‚Ä¶ ‚äï (x‚Çô ‚äï e))))
#+END_SRC

This function just replaces cons ~‚Äú‚à∂‚Äù~ and ~[]~ with ~‚äï~ and ~e~. That's all.
  * E.g., replacing ~:,[]~ with themselves does nothing: ~foldr (:) [] = id~.

#+latex: \newpage
/All functions on lists can be written as folds!/
#+BEGIN_SRC haskell
   h [] = e  ‚àß  h (x:xs) = x ‚äï h xs
‚â°  h = foldr (Œª x rec_call ‚Üí x ‚äï rec_call) e
#+END_SRC
+ Look at the two cases of a function and move them to the two
  first arguments of the fold.
  - ~map f = foldr (Œª x ys ‚Üí f x : ys) []~
  - ~filter p    = foldr (Œª x ys ‚Üí if (p x) then (x:ys) else ys) []~
  - ~takeWhile p = foldr (Œª x ys ‚Üí if (p x) then (x:ys) else []) []~
  # - E.g., ~dropWhile p = foldr (Œª x ys ‚Üí if (p x) then ys else (x:ys)) []~.
# #
You can also fold leftward, i.e., by associating to the left:
#+BEGIN_SRC haskell
foldl (‚äï) e   ‚âà   Œª       (x‚ÇÄ : (x‚ÇÅ : (‚Ä¶ :  (x‚Çô : []))))
                  ‚Üí (((e ‚äï x‚ÇÄ) ‚äï x‚ÇÅ) ‚äï ‚Ä¶ ) ‚äï x‚Çô
#+END_SRC
Unless the operation ~‚äï~ is associative, the folds are generally different.
+ E.g., ~foldl (/) 1 [1..n] ‚âà 1 / n!~ where ~n ! = product [1..n]~.
+ E.g., ~-55 = foldl (-) 0 [1..10] ‚â† foldr (-) 0 [1..10] = -5~.

If ~h~ swaps arguments ---~h(x ‚äï y) = h y ‚äï h x~--- then ~h~ swaps folds:
{{{newline}}}
 ~h . foldr (‚äï) e = foldl (‚äù) e‚Ä≤~ where ~e‚Ä≤ = h e~ and ~x ‚äù y = x ‚äï h y~.

E.g., ~foldl (-) 0 xs = - (foldr (+) 0 xs) = - (sum xs)~
{{{newline}}} and ~n ! = foldr (*) 1 [1..n] = 1 / foldl (/) 1 [1..n]~.

| /( Floating points are a leaky abstraction! )/ |

* Algebraic data types

When we have ‚Äòpossible scenarios‚Äô, we can make a type to consider each option.
E.g., ~data Door = Open | Closed~ makes a new datatype with two different values.
Under the hood, ~Door~ could be implemented as integers and ~Open~ is 0 and ~Closed~
is 1; or any other implementation ---/all that matters/ is that we have a new
type, ~Door~, with two different values, ~Open~ and ~Closed~.

Usually, our scenarios contain a ‚Äòpayload‚Äô of additional information; e.g., ~data
Door2 = Open | Ajar Int | Closed~. Here, we have a new way to construct ~Door~
values, such as ~Ajar 10~ and ~Ajar 30~, that we could interpret as denoting how far
the door is open/. Under the hood, ~Door2~ could be implemented as pairs of
integers, with ~Open~ being ~(0,0)~, ~Ajar n~ being ~(1, n)~, and ~Closed~ being ~(2, 0)~
---i.e., as the pairs ‚Äú(value position, payload data)‚Äù. Unlike functions, a
value construction such as ~Ajar 10~ cannot be simplified any further; just as the
list value ~1:2:3:[]~ cannot be simplified any further. Remember, the
representation under the hood does not matter, what matters is that we have
three possible /construction forms/ of ~Door2~ values.

Languages, such as C, which do not support such an ‚Äúalgebraic‚Äù approach,
force you, the user, to actually choose a particular representation ---even
though, it does not matter, since we only want /a way to speak of/ ‚Äúdifferent
cases, with additional information‚Äù.

In general, we declare the following to get an ‚Äúenumerated type with payloads‚Äù.
#+BEGIN_SRC haskell
data D = C‚ÇÄ œÑ‚ÇÅ œÑ‚ÇÇ ‚Ä¶ œÑ‚Çò | C‚ÇÅ ‚ãØ | C‚Çô ‚ãØ deriving Show
#+END_SRC
There are =n= constructors ~C·µ¢~ that make /different/ values of type ~D~; e.g., ~C‚ÇÄ x‚ÇÅ x‚ÇÇ
‚Ä¶ x‚Çò~ is a ~D~-value whenever each ~x·µ¢~ is a ~œÑ·µ¢~-value. The ~‚Äúderiving Show‚Äù~ at the end
of the definition is necessary for user-defined types to make sure that values
of these types can be printed in a standard form.

We may now define functions on ~D~ by pattern matching on the possible ways to
/construct/ values for it; i.e., by considering the cases ~C·µ¢~.

In-fact, we could have written ~data D Œ±‚ÇÅ Œ±‚ÇÇ ‚Ä¶ Œ±‚Çñ = ‚ãØ~, so that we speak of ‚ÄúD
values /parameterised/ by types Œ±·µ¢‚Äù. E.g., ‚Äúlists whose elements are of type Œ±‚Äù is
defined by ~data List Œ± = Nil | Cons Œ± (List Œ±)~ and, for example, ~Cons 1 (Cons 2
Nil)~ is a value of ~List Int~, whereas ~Cons 'a' Nil~ is of type ~List Char~. ---The
~List~ type is missing the ~‚Äúderiving Show‚Äù~, see below for how to /mixin/ such a
feature.

For example, suppose we want to distinguish whether we have an Œ±-value or a
Œ≤-value, we use ~Either~. Let's then define an example /infix/ function using
pattern matching.
#+BEGIN_SRC haskell
data Either Œ± Œ≤ = Left Œ± | Right Œ≤

(+++) :: (Œ± ‚Üí Œ±‚Ä≤) ‚Üí (Œ≤ ‚Üí Œ≤‚Ä≤) ‚Üí Either Œ± Œ≤ ‚Üí Either Œ±‚Ä≤ Œ≤‚Ä≤
(f +++ g) (Left  x) = Left $ f x
(f +++ g) (Right x) = Right $ g x

right :: (Œ≤ ‚Üí œÑ) ‚Üí Either Œ± Œ≤ ‚Üí Either Œ± œÑ
right f = id +++ f
#+END_SRC
The above ~(+++)~ can be found in ~Control.Arrow~ and is also known as ~either~ in the
standard library.

* Typeclasses and overloading

/Overloading/ is using the same name to designate operations ‚Äúof the same nature‚Äù
on values of different types.

E.g., the ~show~ function converts its argument into a string; however, it is not
polymorphic: We cannot define ~show :: Œ± ‚Üí String~ with one definition since some
items, like functions or infinite datatypes, cannot be printed and so this is
not a valid type for the function ~show~.

Haskell solves this by having ~Show~ /typeclass/ whose /instance types/ ~Œ±~ each
implement a definition of the /class method/ ~show~. The type of ~show~ is written
~Show Œ± => Œ± -> String~: /Given an argument of type ~Œ±~, look in the global listing of
~Show~ instances, find the one for ~Œ±~, and use that;/ if ~Œ±~ has no ~Show~ instance,
then we have a type error. One says ‚Äúthe type variable ~Œ±~ has is /restricted/ to be
a ~Show~ instance‚Äù ---as indicated on the left side of the ~‚Äú=>‚Äù~ symbol.

E.g., for the ~List~ datatype we defined, we may declare it to be ‚Äòshowable‚Äô like
so:
#+begin_quote org
  #+BEGIN_SRC haskell -n 1
  instance Show a => Show (List a) where
    show Nil         = "Nope, nothing here"
    show (Cons x xs) = "Saw " ++ show x ++ ", then " ++ show xs
  #+END_SRC
#+end_quote
That is:
  1. /If ~a~ is showable, then ~List a~ is also showable./
  2. /Here's how to show ~Nil~ directly./
  3. /We show ~Cons x xs~ by using the ~show~ of ~a~ on ~x~, then recursively showing ~xs~./

|             | Common Typeclasses                                 |
|-------------+----------------------------------------------------|
| ~Show~        | Show elements as strings, ~show~                     |
| ~Read~        | How to read element values from strings, ~read~      |
| ~Eq~          | Compare elements for equality, ~==~                  |
| ~Num~         | Use literals ~0, 20, ‚Ä¶,~ and arithmetic ~+, *, -~      |
| ~Ord~         | Use comparison relations ~>, <, >=, <=~               |
| ~Enum~        | Types that can be listed, ~[start .. end]~           |
| ~Monoid~      | Types that model ‚Äò(untyped) composition‚Äô           |
| ~Functor~     | /Type formers/ that model effectful computation      |
| ~Applicative~ | Type formers that can sequence effects             |
| ~Monad~       | Type formers that let effects depend on each other |

The ~Ord~ typeclass is declared ~class Eq a => Ord a where ‚ãØ~, so that all ordered
types are necessarily also types with equality. One says ~Ord~ is a /subclass/ of
~Eq~; and since subclasses /inherit/ all functions of a class, we may always replace
~(Eq a, Ord a) => ‚ãØ~ by ~Ord a => ‚ãØ~.

You can of-course define your own typeclasses; e.g., the ~Monoid~ class in Haskell
could be defined as follows.
#+BEGIN_SRC haskell
class Semigroup a where
  (<>) :: a -> a -> a  {- A way to ‚Äúcompose‚Äù elements together -}
  {- Axiom: (x <> y) <> z = x <> (y <> z) -}

class Semigroup a => Monoid a where
  mempty :: a   {- Axiom: This is a ‚Äòno-op‚Äô, identity, for composition <> -}
#+END_SRC
Example monoids ~(Œ±, <>, mempty)~ include ~(Int, +, 0)~, ~([Œ±], ++, [])~, and
{{{newline}}} (Program statements, sequence ‚Äú;‚Äù, the empty statement) ---this
last example is approximated as ~Term~ with ‚Äòlet-in‚Äô clauses at the end of this
cheatsheet. /Typeclasses are interfaces, possibly with axioms specifying their
behaviour./

As shown earlier, Haskell provides a the ~deriving~ mechanism for making it easier
to define instances of typeclasses, such as ~Show, Read, Eq, Ord, Enum~. How?
Constructor names are printed and read as written as written in the ~data~
declaration, two values are equal if they are formed by the same construction,
one value is less than another if the constructor of the first is declared in
the ~data~ definition before the constructor of the second, and similarly for
listing elements out.
* Functor

/Functors are type formers that ‚Äúbehave‚Äù like collections: We can alter their/
/‚Äúelements‚Äù without messing with the ‚Äòcollection structure‚Äô or ‚Äòelement
positions‚Äô./ The well-behavedness constraints are called /the functor axioms/.
#+BEGIN_SRC haskell
class Functor f where
  fmap :: (Œ± ‚Üí Œ≤) ‚Üí f Œ± ‚Üí f Œ≤

(<$>) = fmap {- An infix alias -}
#+END_SRC

The axioms cannot be checked by Haskell, so we can form instances that fail to
meet the implicit specifications ---two examples are below.

** Identity Axiom

*Identity Law*: ~fmap id = id~

/Doing no alteration to the contents of a collection does nothing to the collection./

This ensures that ‚Äúalterations don't needlessly mess with element values‚Äù
e.g., the following is not a functor since it does.
#+BEGIN_SRC haskell :tangle probably.hs
{- I probably have an item -}
data Probably a = Chance a Int

instance Functor Probably where
  fmap f (Chance x n) = Chance (f x) (n `div` 2)
#+END_SRC

** Fusion Axiom
*Fusion Law:* ~fmap f . fmap g = fmap (f . g)~

/Reaching into a collection and altering twice is the same as reaching in and
altering once./

This ensures that ‚Äúalterations don't needlessly mess with collection structure‚Äù;
e.g., the following is not a functor since it does.

#+BEGIN_SRC haskell :tangle pocket.hs
import Prelude hiding (Left, Right)

{- I have an item in my left or my right pocket -}
data Pocket a = Left a | Right a

instance Functor Pocket where
  fmap f (Left  x) = Right (f x)
  fmap f (Right x) = Left  (f x)
#+END_SRC

** Functors do not necessarily ‚Äòcontain‚Äô anything

It is important to note that functors model well-behaved container-like types,
but of-course the types do not actually need to contain anything at all! E.g.,
the following is a valid functor.
#+BEGIN_SRC haskell :tangle Liar.hs
{- ‚ÄúI totally have an Œ±-value, it's either here or there.‚Äù Lies! -}
data Liar Œ± = OverHere Int | OverThere Int

instance Functor Liar where
  fmap f (OverHere  n) = OverHere  n
  fmap f (OverThere n) = OverThere n
#+END_SRC
Notice that if we altered ~n~, say by dividing it by two, then we break the
identity law; and if we swap the constructors, then we break the fusion law.
Super neat stuff!

In general, functors take something boring and generally furnish it with
‚Äòcoherent‚Äô structure, but *there is not necessarily an Œ± ‚Äòinside‚Äô f Œ±*.
E.g., ~f Œ± = (Œµ ‚Üí Œ±)~ has as values ‚Äúrecipes for forming an Œ±-value‚Äù,
but unless executed, there is no ~Œ±~-value.

** Misc results about Functors

#+latex: \vspace{0.5em}
+ ~fmap f xs~ ‚âà /for each/ element ~x~ in the ‚Äòcollection‚Äô ~xs~, yield ~f x~.
+ Haskell can usually ~derive~ functor instances since they are [[http://archive.fo/U8xIY][unique]]: Only one
  possible definition of ~fmap~ will work.
  :Proof:
  Suppose we have a functor f and another function

foo :: (a -> b) -> f a -> f b

Then as a consequence of the free theorem for foo,
for any f :: a -> b and any g :: b -> c.

foo (g . f) = fmap g . foo f

In particular, if foo id = id, then

foo g = foo (g . id) = fmap g . foo id = fmap g . id = fmap g
  :End:
+ Reading the functor axioms left-to-right, they can be seen as /optimisation laws/
  that make a program faster by reducing work.
+ The two laws together say /fmap distributes over composition/: {{{newline}}}
  ~fmap (f‚ÇÅ . f‚ÇÇ . ‚ãØ . f‚Çô) = fmap f‚ÇÅ . ‚ãØ . fmap f‚Çô~ for ~n ‚â• 0~.

*Naturality Theorems:* If ~p ‚à∑ f a ‚Üí g a~ for some /functors/ ~f~ and ~g~, {{{newline}}}
then ~fmap f . p = p . fmap f~ for any /function/ ~f~.

Hence, any generic property ~p ‚à∑ f Œ± ‚Üí Œµ~ is invariant over fmaps:
~p(fmap¬†f¬†xs)¬†=¬†p‚ÄØxs~. E.g., the length of a list does not change even when an
fmap is applied.
# - This is the naturality theorem for ~p~ where ~g a = Œµ~ is the constantly-~Œµ~ functor.

* Functor Examples

Let ~f‚ÇÅ, f‚ÇÇ~ be functors and ~Œµ~ be a given type.

| Type Former | ~f Œ±~                  | ~f <$> x~                             |
|-------------+----------------------+-------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity][Identity]]    | ~Œ±~                    | ~f <$> x =  x~                        |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const][Constant]]    | ~Œµ~                    | ~f <$> x = x~                         |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-List.html][List]]        | ~[Œ±]~                  | ~f <$> [x‚ÇÄ, ‚Ä¶, x‚Çô] = [f x‚ÇÄ, ‚Ä¶, f x‚Çô]~ |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either][Either]]      | ~Either Œµ Œ±~           | ~f <$> x = right f~                   |
|-------------+----------------------+-------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html#t:Product][Product]]     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~         | ~f <$> (x, y) = (f <$> x, f <$> y)~   |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose][Composition]] | ~f‚ÇÅ (f‚ÇÇ Œ±)~            | ~f <$> x = (fmap f) <$> x~            |
| [[http://comonad.com/reader/2012/abstracting-with-applicatives/][Sum]]         | ~Either (f‚ÇÅ Œ±) (f‚ÇÇ Œ±)~ | ~f <$> ea = f +++ f~                    |
|-------------+----------------------+-------------------------------------|
| [[http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]]      | ~(Œµ, Œ±)~               | ~f <$> (e, x) = (e, f x)~             |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html][Reader]]      | ~Œµ ‚Üí Œ±~                | ~f <$> g = f . g~                     |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]]       | ~Œµ ‚Üí (Œµ, Œ±)~           | ~f <$> g = second f . g~              |

Notice that writer is the product of the constant and the identity functors.

Unlike reader, the type former ~f Œ± = Œ± ‚Üí Œµ~ is /not/ a functor since there is no
way to implement ~fmap~. In contrast, ~f Œ± = (Œ± ‚Üí Œµ, Œ±)~ /does/ have an implementation
of ~fmap~, but it is not lawful.
# It fails the identity axiom.

* Applicative
  # ---Protecting against invalid input

/Applicatives are collection-like types that can apply collections of functions
to collections of elements./

In particular, /applicatives can fmap over multiple arguments/; e.g., if we try to
add ~Just 2~ and ~Just 3~, we find =(+) <$> Just 2 :: Maybe (Int ‚Üí Int)= and this is
not a function and so cannot be applied further to ~Just 3~ to get ~Just 5~.
We have both the function and the value wrapped up, so we need a way to apply
the former to the latter. The answer is ~(+) <$> Just 2 <*> Just 3~.

#+BEGIN_SRC haskell
class Functor f => Applicative f where
  pure   :: a -> f a
  (<*>)  :: f (a -> b) -> f a -> f b  {- ‚Äúapply‚Äù -}

{- Apply associates to the left: p <*> q <*> r = (p <*> q) <*> r) -}
#+END_SRC

The method ~pure~ lets us inject values, to make ‚Äòsingleton collections‚Äô.

# Main idea
+ /Functors transform values inside collections; applicatives can additionally
  combine values inside collections./
+ Exercise: If ~Œ±~ is a monoid, then so too is ~f Œ±~ for any applicative ~f~.

** Axioms
The applicative axioms ensure that apply behaves like usual functional application:

+ Identity: ~pure id <*> x = x~ ---c.f., ~id x = x~
+ Homomorphism: ~pure f <*> pure x = pure (f x)~ ---it really is function application
  on pure values!
  - Applying a non-effectful function to a non-effectful argument in an effectful
    context is the same as just applying the function to the argument and then
    injecting the result into the content.
+ Interchange: ~p <*> pure x = pure ($ x) <*> p~ ---c.f., ~f x = ($ x) f~
  - Functions ~f~ take ~x~ as input ‚âà Values ~x~ project functions ~f~ to particular values
  - When there is only one effectful component, then it does not matter whether
    we evaluate the function first or the argument first, there will still only be
    one effect.
  - Indeed, this is equivalent to the law: ~pure f <*> q = pure (flip ($)) <*> q <*> pure f~.

+ Composition: ~pure (.) <*> p <*> q <*> r = p <*> (q <*> r)~
  {{{newline}}} ---c.f., ~(f . g) . h = f . (g . h)~.

If we view ~f Œ±~ as an ‚Äúeffectful computation on Œ±‚Äù, then the above laws ensure
~pure~ creates an ‚Äúeffect free‚Äù context. E.g., if ~f Œ± = [Œ±]~ is considered
‚Äúnondeterminstic Œ±-values‚Äù, then ~pure~ just treats usual Œ±-values as
nondeterminstic but with no ambiguity, and ~fs <*> xs~ reads ‚Äúif we
nondeterminsticly have a choice ~f~ from ~fs~, and we nondeterminsticly an ~x~ from
~xs~, then we nondeterminsticly obtain ~f x~.‚Äù More concretely, if I'm given
randomly addition or multiplication along with the argument 3 and another
argument that could be 2, 4, or 6, then the result would be obtained by
considering all possible combinations: ~[(+), (*)] <*> pure 3 <*> [2, 4, 6] =
[5,7,9,6,12,18]~. The name ~‚Äú<*>‚Äù~ is suggestive of this ‚Äòcartesian product‚Äô nature.

Given a definition of apply, the definition of ~pure~ may be obtained
by unfolding the identity axiom.
# Given a definition of apply, the definition of ~pure~ is then unique.
# Proof?

Using these laws, we regain ~fmap~ thereby further cementing that applicatives
model ‚Äúcollections that can be functionally applied‚Äù: ~f <$> x = pure f <*> x~.
( Hence, every applicative is a functor whether we like it or not. )
- The homomorphism law now becomes: ~pure . f = fmap f . pure~.
  # i.e., ~Œª x ‚Üí pure (f x) = Œª x ‚Üí fmap f (pure x)~.
  * This is the ‚Äúnaturality law‚Äù for ~pure~.
:Proof:
fmap f (pure x)
= f <$> pure x
= pure f <*> pure x
= pure (f x)
:End:

** Canonical Form -- =liftN=

[[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][The laws]] may be interpreted as left-to-right rewrite rules and so are a
 procedure for transforming any applicative expression into the canonical form
 of ‚Äúa pure function applied to effectful arguments‚Äù: ~pure f <*> x‚ÇÅ <*> ‚ãØ <*>
 x‚Çô~. In this way, one can compute in-parallel the, necessarily independent, ~x·µ¢~
 then combine them together.

Notice that the canonical form generalises ~fmap~ to ~n~-arguments: {{{newline}}}
Given ~f ‚à∑ Œ±‚ÇÅ ‚Üí ‚ãØ ‚Üí Œ±‚Çô ‚Üí Œ≤~ and ~x·µ¢ ‚à∑ f Œ±·µ¢~, we obtain an ~(f Œ≤)~-value. {{{newline}}}
The case of ~n = 2~ is called ~liftA2~, ~n = 1~ is just ~fmap~, and for ~n = 0~ we have
~pure~!

:More:
The ~ApplicativeDo~ extension permits a different
style for the canonical form:
#+BEGIN_SRC haskell
do v‚ÇÅ ‚Üê x‚ÇÅ
    ‚ãÆ
   v‚Çô ‚Üê x‚Çô
   pure (f v‚ÇÅ v‚ÇÇ ‚Ä¶ v‚Çô)
#+END_SRC
:End:
# For more details, see Applicative Programming with Effects, by Conor McBride
# and Ross Paterson.
** Monoidal Presentation

Notice that ~lift2A~ is essentially the cartesian product in the setting of lists,
or ~(<&>)~ below ---c.f., ~sequenceA :: Applicative f ‚áí [f a] ‚Üí f [a]~.

  #+BEGIN_SRC haskell
(<&>) :: f a ‚Üí f b ‚Üí f (a, b)   {- Not a standard name! -}
(<&>) = liftA2 (,)  -- i.e., p <&> q = (,) <$> p <*> q
#+END_SRC
This is a pairing operation with properties of ~(,)~ mirrored at the applicative level:
#+BEGIN_SRC haskell
{- Pure Pairing -} pure x <&> pure y = pure (x, y)
{- Naturality   -} (f &&& g) <$> (u <&> v) = (f <$> u) <&> (g <&> v)

{- Left Projection  -} fst <$> (u <&> pure ()) = u
{- Right Projection -} snd <$> (pure () <&> v)  = v
{- Associtivity     -} assocl <$> (u <&> (v <&> w)) = (u <&> v) <&> w
#+END_SRC
:PurePairing_Proof:
#+BEGIN_SRC haskell
  pure x <&> pure y
= (,) <$> pure x <*> pure y
= pure (,) <*> pure x <*> pure y
= pure (x,) <*> pure y
= pure (x,y)
#+END_SRC
:End:
The final three laws above suffice to prove the original applicative axioms, and so
we may define ~p <*> q = uncurry ($) <$> (p <&> q)~.
# Naturality, in the context of Haskell, is a free theorem.

* Applicative Examples

Let ~f‚ÇÅ, f‚ÇÇ~ be functors and let ~Œµ~ a type.

| Functor     | ~f Œ±~                  | ~f <*> x~                                 |
|-------------+----------------------+-----------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity][Identity]]    | ~Œ±~                    | ~f <*> x = f x~                           |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const][Constant]]    | ~Œµ~                    | ~e <*> d = e <> d~                        |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-List.html][List]]        | ~[Œ±]~                  | =fs <*> xs = [f x ‚à£ f <- fs, x <- xs]=    |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either][Either]]      | ~Either Œµ Œ±~           | ~ef <*> ea = right (Œª f ‚Üí right f ea) ef~ |
|-------------+----------------------+-----------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose][Composition]] | ~f‚ÇÅ (f‚ÇÇ Œ±)~            | ~f <*> x = (<*>) <$> f <*> x~             |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html#t:Product][Product]]     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~         | ~(f, g) <*> (x, y) = (f <*> x, g <*> y)~  |
| [[http://comonad.com/reader/2012/abstracting-with-applicatives/][Sum]]         | ~Either (f‚ÇÅ Œ±) (f‚ÇÇ Œ±)~ | Challenge: Assume ~Œ∑ ‚à∑ f‚ÇÅ a ‚Üí f‚ÇÇ a~       |
|-------------+----------------------+-----------------------------------------|
| [[http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]]      | ~(Œµ, Œ±)~               | ~(a , f) <*> (b, x) = (a <> b, f x)~      |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html][Reader]]      | ~Œµ ‚Üí Œ±~                | ~f <*> g = Œª e ‚Üí f e (g e)~  ---c.f., ~SKI~ |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]]       | ~Œµ ‚Üí (Œµ, Œ±)~           | ~sf <*> sa = Œª e ‚Üí let (e‚Ä≤, f) = sf e~    |
|             |                      | ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ‚ÄØ  ~in second f (sa e‚Ä≤)~  |

In the writer and constant cases, we need ~Œµ~ to also be a monoid.
When Œµ is /not/ a monoid, then those two constructions give examples of functors
that are /not/ applicatives ---since there is no way to define ~pure~.
In contrast, ~f Œ± = (Œ± ‚Üí Œµ) ‚Üí Maybe Œµ~ is not an applicative since no
definition of apply is lawful.

Since readers ~((->) r)~ are applicatives, we may, for example, write ~(‚äï) <$> f
<*> g~ as a terse alternative to the ‚Äúpointwise ‚äï‚Äù method ~Œª x ‚Üí f x ‚äï g x~. E.g.,
using ~(&&)~ gives a simple way to chain predicates.
:Indeed:
#+BEGIN_SRC haskell
  (‚äï) <$> f <*> g
=  (pure (‚äï) <*> f) <*> g
=  Œª x ‚Üí (pure (‚äï) <*> f) x (g x)
=  Œª x ‚Üí pure (‚äï) x (f x) (g x)
=  Œª x ‚Üí (‚äï) (f x) (g x)
= Œª x ‚Üí f x ‚äï g x
#+END_SRC

:End:

:Table_with_pure:
| Functor     | ~f Œ±~                  | ~pure a~           | ~f <*> x~                                |
|-------------+----------------------+------------------+----------------------------------------|
| Identity    | ~Œ±~                    | ~a~                | ~f x~                                    |
| Constant    | ~Œµ~                    | ~mempty~           | ~f <> x~                                 |
| List        | ~[Œ±]~                  | ~[a]~              | =fs <*> xs = [f x ‚à£ f <- fs, x <- xs]=   |
| Either      | ~Either Œµ Œ±~           | ~Right a~      | ~right (Œª f ‚Üí right f ea) ef~            |
|-------------+----------------------+------------------+----------------------------------------|
| Composition | ~f‚ÇÅ (f‚ÇÇ Œ±)~            | ~pure (pure a)~    | ~f <*> x = (<*>) <$> f <*> x~            |
| Product     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~         | ~(pure a, pure a)~ | ~(f, g) <*> (x, y) = (f <*> x, g <*> y)~ |
| Sum         | ~Either (f‚ÇÅ Œ±) (f‚ÇÇ Œ±)~ |                  | ~f <$> ea = f +++ f~                       |
|-------------+----------------------+------------------+----------------------------------------|
| Writer      | ~(Œµ, Œ±)~               | ~(mempty, a)~      | ~(a , f) <*> (b, x) = (a <> b, f x)~     |
| Reader      | ~Œµ ‚Üí Œ±~                | ~Œª _ ‚Üí a~          | ~f <*> g = Œª x ‚Üí f x (g x)~  --i.e., ~S~   |
:End:

* ~Do~-Notation ---Subtle difference between applicatives and monads
  Recall the ~map~ operation on lists, we could define it ourselves:
#+BEGIN_SRC haskell :tangle delme.hs
map' :: (Œ± -> Œ≤) -> [Œ±] -> [Œ≤]
map' f []     = []
map' f (x:xs) = let y  = f x
                    ys = map' f xs
                in  (y:ys)
#+END_SRC
If instead the altering function ~f~ returned effectful results,
then we could gather the results along with the effect:
#+BEGIN_SRC haskell :tangle delme1.hs
{-# LANGUAGE ApplicativeDo #-}

mapA :: Applicative f => (a -> f b) -> [a] -> f [b]
mapA f []     = pure []
mapA f (x:xs) = do y  <- f x
                   ys <- mapA f xs
                   pure (y:ys)
                {- ‚âà (:) <$> f x <*> mapA f xs -}
#+END_SRC

Applicative syntax can be a bit hard to write, whereas ~do~-notation is more
natural and reminiscent of the imperative style used in defining ~map'~ above. For
instance, the intuition that ~fs <*> ps~ is a cartesian product is clearer in
do-notation: ~fs <*> ps ‚âà do {f ‚Üê fs; x ‚Üê ps; pure (f x)}~ where the right side is
read /‚Äúfor-each f in fs, and each x in ps, compute f x‚Äù/.

#+latex: \columnbreak
# ‚ÄúDesugaring Haskell‚Äôs do-Notation into Applicative Operations‚Äù
[[https://dl.acm.org/doi/pdf/10.1145/3241625.2976007][In-general]], ~do {x‚ÇÅ ‚Üê p‚ÇÅ; ‚Ä¶; x‚Çô ‚Üê p‚Çô; pure e} ‚âà pure (Œª x‚ÇÅ ‚Ä¶ x‚Çô ‚Üí e) <*> p‚ÇÅ <*> ‚ãØ
<*> p‚Çô~ *provided* ~p·µ¢~ does not mention ~x‚±º~ for ~j < i~; but =e= may refer to all ~x·µ¢~. If
any ~p·µ¢~ mentions an earlier ~x‚±º~, then we could not translate the ~do~-notation into
an applicative expression.

If ~do {x ‚Üê p; y ‚Üê qx; pure e}~ has ~qx~ being an expression *depending* on ~x~,
then we could say this is an abbreviation for ~(Œª x ‚Üí (Œª y ‚Üí e) <$> qx) <$> p~
but this is of type ~f (f Œ≤))~. Hence, to allow later computations to depend
on earlier computations, we need a method ~join :: f (f Œ±) ‚Üí f Œ±~ with which
we define {{{newline}}} ~do {x ‚Üê p; y ‚Üê qx; pure e} ‚âà join $ ~(Œª x -> (Œª y ‚Üí e) <$> qx) <$> p~.

Applicatives with a ~join~ are called monads and they give us a *‚Äúprogrammable
semicolon‚Äù*. Since later items may depend on earlier ones, ~do {x ‚Üê p; y ‚Üê q;
pure e}~ could be read /‚Äúlet x be the value of computation p, let y be the value
of computation q, then combine the values via expression e‚Äù/. Depending on how
~<*>~ is implemented, such ‚Äòlet declarations‚Äô could short-circuit (~Maybe~) or be
nondeterministic (~List~) or have other effects such as altering state.

As the ~do~-notation clearly shows, the primary difference between =Monad= and
=Applicative= is that =Monad= allows dependencies on previous results, whereas
=Applicative= does not.

:TypeChecking:
#+BEGIN_SRC haskell :tangle delme_0.hs
p‚ÇÅ :: Applicative f => f Œ±
p‚ÇÅ = undefined

p‚ÇÇ :: Applicative f => Œ± -> f Œ≤
p‚ÇÇ = undefined

data C = C

e :: Œ± -> Œ≤ -> C
e = undefined

this :: Applicative f => f (f C)
-- this = e <$> p‚ÇÅ <*> undefined
this = (\ x‚ÇÅ -> e x‚ÇÅ <$> p‚ÇÇ x‚ÇÅ) <$> p‚ÇÅ
#+END_SRC
:End:

** Do-notation with tuples and functions

Do-syntax also works with tuples and functions --c.f., reader monad below---
since they are monadic; e.g., every clause ~x <- f~ in a functional do-expression
denotes the resulting of applying ~f~ to the (implicit) input.
More concretely:
#+BEGIN_SRC haskell
go :: (Show a, Num a) => a -> (a, String)
go = do {x <- (1+); y <- show; return (x, y)}

-- go 3 = (4, "3")
#+END_SRC

Likewise, tuples, lists, etc.

* Formal Definition of ~Do~-Notation

For a general applicative ~f~, a ~do~ expression has the form ~do {C; r}~, where ~C~ is
a (possibly empty) list of commands separated by semicolons, and ~r~ is an
expression of type ~f Œ≤~, which is also the type of the entire ~do~ expression. Each
command takes the form ~x ‚Üê p~, where ~x~ is a variable, or possibly a pattern; if ~p
:: f Œ±~ then ~x :: Œ±~. In the particular case of the anonymous variable, ~_ ‚Üê p~ may
be abbreviated to ~p~.

The translation of a ~do~ expression into ~<*>/join~ operations and ~where~ clauses is
governed by three rules ---the last one only applies in the setting of a monad.
#+BEGIN_SRC haskell
(1)  do {r}           = r
(2A) do {x ‚Üê p; C; r} = q <*> p where q x = do {C; r} --Provided x ‚àâ C
(2M) do {x ‚Üê p; C; r} = join $ map q p where q x = do {C; r}

{- Fact: When x ‚àâ C, (2A) = (2M). -}
#+END_SRC

By definition chasing and induction on the number of commands ~C~, we have:
#+BEGIN_SRC haskell
[CollapseLaw]  do {C; do {D; r}} = do {C; D; r}
#+END_SRC
:Proof:
#+BEGIN_SRC haskell
{- Proof:
   [base] do {do {D; r}} = do {D; r} ‚úì
   [ind]  do {x ‚Üê p; C‚Ä≤; do {D; r}}  -- case: x ‚àâ C
        = q <*> p where q x = do {C‚Ä≤; do {D; r}}
        = q <*> p where q x = do {C‚Ä≤; D; r}
        = do {x ‚Üê p; C‚Ä≤; D; r} ‚úì
   [ind]  do {x ‚Üê p; C‚Ä≤; do {D; r}}  -- case: x may be in C
        = join $ map q p where q x = do {C‚Ä≤; do {D; r}}
        = join $ map q p where q x = do {C‚Ä≤; D; r}
        = do {x ‚Üê p; C‚Ä≤; D; r} ‚úì
-}
#+END_SRC
:End:

Likewise:
#+BEGIN_SRC haskell
[Map ] fmap f p = do {x ‚Üê p; pure (f x)} -- By applicative laws
[Join] join ps  = do {p ‚Üê ps; p}         -- By functor laws
#+END_SRC

*Do-Notation Laws*: Here are some desirable usability properties of ~do~-notation.
#+BEGIN_SRC haskell
[RightIdentity]  do {B; x ‚Üê p; pure x}       = do {B; p}
[LeftIdentity ]  do {B; x ‚Üê pure e; C; r}    = do {B; C[x ‚âî e]; r[x ‚âî e]}
[Associtivity ]  do {B; x ‚Üê do {C; p}; D; r} = do {B; C; x ‚Üê p; D; r}
#+END_SRC

Here, ~B, C, D~ range over sequences of commands and ~C[x ‚âî e]~ means the sequence ~C~
with all free occruences of ~x~ replaced by ~e~.

+ Associtivity gives us a nice way to ‚Äòinline‚Äô other calls.
+ The LeftIdentity law, read right-to-left, lets us ‚Äúlocally give a name‚Äù to the
  possibly complex expression ~e~.

  If ~pure~ forms a singleton collection, then LeftIdentity is a ‚Äúone-point rule‚Äù:
  We consider /all/ ~x ‚Üê pure e~, but there is only /one/ such ~x~, namely ~e~!
  # - In list notation: ~[g x | x <- pure e] = [g e]~.

In the applicative case, where the clauses are independent, we can prove, say,
~RightIdentity~ using the identity law for applicatives ---which says essentially
{{{newline}}}
~do {x <- p; pure x} = p~--- then apply induction on the length of ~B~.

:Hide:
#+BEGIN_SRC haskell
-- applicative laws
[Homomorphism] do {x <- pure e; pure (f x)} = pure (f e)
#+END_SRC
:End:

What axioms are needed for the monad case to prove the ~do~-notation laws?

* Monad Laws
  # ---‚Äúthe programmable semicolon‚Äù*

Here is the definition of the monad typeclass.
#+BEGIN_SRC haskell :tangle del_4.hs
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b

(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
f <=< g = join . fmap f . g
#+END_SRC

Where's ~join~!? Historically, monads entered Haskell first with interface ~(>>=),
return~; later it was realised that ~return = pure~ and the relationship with
applicative was cemented.

‚ÄòBind‚Äô ~(>>=)~ is definable from ~join~ by ~ma >>= f = join (fmap f ma)~, and, for
this reason, bind is known as ‚Äúflat map‚Äù or ‚Äúconcat map‚Äù in particular
instances. For instance, the second definition of ~do~-notation could be
expressed:
#+BEGIN_SRC haskell
(2M‚Ä≤) do {x ‚Üê p; C; r} = p >>= q where q x = do {C; r}
#+END_SRC
Conversely, ~join ps = do {p ‚Üê ps; p} = ps >>= id~. Likewise, with (2M‚Ä≤), note how
~(<*>)~ can be defined directly in-terms of ~(>>=)~
{{{newline}}}
---c.f., ~mf <*> mx = do {f ‚Üê mf;
x ‚Üê mx; return (f x)}~.

Since ~fmap f p = do {x ‚Üê p; return (f x)} = p >>= return . f~, in the past monad
did not even have functor as a superclass ---c.f., [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:liftM][liftM]].

:FlipBind:

(=<<) :: Monad m => (a -> m b) -> m a -> m b
    -- Defined in ‚ÄòGHC.Base‚Äô
infixr 1 =<<

:End:

The properties of ~>>=, return~ that prove the desired ~do~-notation laws are:
#+BEGIN_SRC haskell
[LeftIdentity ] return a >>= f   ‚â°  f a
[RightIdentity] m >>= return     ‚â°  m
[Associtivity ] (m >>= f) >>= g  ‚â°  m >>= (\x -> f x >>= g)
                i.e.,   (m  >>=  (\x -> f x))  >>=  g
                       = m  >>=  (\x -> f x    >>=  g)
#+END_SRC

Equivalently, show the ‚Äòfish‚Äô ~(<=<)~ is associative with identity being ~pure~
---c.f., monoids!

It is pretty awesome that ~(>>=), return~ give us a functor, an applicative, and
(dependent) do-notation! Why? Because bind does both the work of ~fmap~ and ~join~.
Thus, ~pure, fmap, join~ suffice to characterise a monad.

| /Join determines how a monad behaves!/ |

The monad laws can be expressed in terms of ~join~ [[https://en.wikibooks.org/wiki/Haskell/Category_theory#The_monad_laws_and_their_importance][directly]]:
#+BEGIN_SRC haskell
[Associativity] join . fmap join = join . join
{- The only two ways to get from ‚Äúm (m (m Œ±))‚Äù to ‚Äúm Œ±‚Äù are the same. -}

[Identity Laws] join. fmap pure = join . pure = id
{- Wrapping up ‚Äúm Œ±‚Äù gives an ‚Äúm (m Œ±)‚Äù which flattens to the original element. -}
#+END_SRC
#    # - The left-hand side will flatten the inner two layers into a new layer,
#    # - then flatten this with the outermost layer. The right-hand side will
#    # - flatten the outer two layers, then flatten this with the innermost
#    # - layer.

Then, notice that the (free) naturality of join is:
#+BEGIN_SRC haskell
join . fmap (fmap f) = fmap f . join  ‚à∑  m (m Œ±) ‚Üí m Œ≤
#+END_SRC

# Cool.
# Notice that ~fmap f p = do { x ‚Üê p; pure (f x) } = join $ fmap (pure . f) p~

 Again, note that ~join~ doesn't merely flatten a monad value, but rather performs
 the necessary logic that determines /how the monad behaves/.
 # Indeed, ~join, pure, fmap~ suffice to characterise a monad.

 E.g., suppose ~m Œ± = Œµ ‚Üí (Œµ, Œ±)~ is the type of ~Œ±~-values that can be configured
 according to a fixed environment type ~Œµ~, along with the possibly updated
 configuration ---i.e., functions ~Œµ ‚Üí (Œµ, Œ±)~. Then any ~a ‚à∂ Œµ ‚Üí (Œµ, Œµ ‚Üí (Œµ, Œ±))~ in ~m
 (m Œ±)~ can be considered an element of ~m Œ±~ if we /propagate the environment
 configuration/ through the outer layer to obtain a new configuration for the
 inner layer: ~Œª e ‚Üí let (e‚Ä≤, a‚Ä≤) = a e in a‚Ä≤ e‚Ä≤~. The join dictates how a
 configuration is /modified then passed along/: We have two actions, ~a~ and ~a‚Ä≤~, and
 join has /sequenced/ them by pushing the environment through the first thereby
 modifying it then pushing it through the second.

* Monad Examples

Let ~f‚ÇÅ, f‚ÇÇ~ be functors and let ~Œµ~ a type.

| Applicative | ~m Œ±~          | ~join :: m (m Œ±) ‚Üí m Œ±~                   |
|-------------+--------------+-----------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity][Identity]]    | ~Œ±~            | ~Œª x ‚Üí x~                                 |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const][Constant]]    | ~Œµ~            | ~Œª x ‚Üí x~  ---Shucks!                     |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-List.html][List]]        | ~[Œ±]~          | ~Œª xss ‚Üí foldr (++) [] xss~               |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either][Either]]      | ~Either Œµ Œ±~   | Exercise ^_^                            |
|-------------+--------------+-----------------------------------------|
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose][Composition]] | ~f‚ÇÅ (f‚ÇÇ Œ±)~    | [[https://stackoverflow.com/q/7040844/3550444][Nope! Not a monad!]]                      |
| [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html#t:Product][Product]]     | ~(f‚ÇÅ Œ±, f‚ÇÇ Œ±)~ | ~Œª p ‚Üí (fst <$> p, snd <$> p)~            |
|-------------+--------------+-----------------------------------------|
| [[http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]]      | ~(Œµ, Œ±)~       | ~Œª (e, (e‚Ä≤, a)) ‚Üí (e <> e‚Ä≤, a)~           |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html][Reader]]      | ~Œµ ‚Üí Œ±~        | ~Œª ra ‚Üí Œª e ‚Üí ra e e~                     |
| [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]]       | ~Œµ ‚Üí (Œµ, Œ±)~   | ~Œª ra ‚Üí Œª e ‚Üí let (e‚Ä≤, a) = ra e in a e‚Ä≤~ |
#  #
# | [[http://comonad.com/reader/2012/abstracting-with-applicatives/][Sum]]         | ~Either (f‚ÇÅ Œ±) (f‚ÇÇ Œ±)~ | Challenge: Assume ~Œ∑ ‚à∑ f‚ÇÅ a ‚Üí f‚ÇÇ a~       |

In writer, we need ~Œµ~ to be a monoid.

+ Notice how, in writer, join merges the outer context with the inner context:
  /Sequential writes are mappended together!/
+ If ~pure~ forms ‚Äòsingleton containers‚Äô then ~join~ flattens containers of containers
  into a single container.

Excluding the trivial monoid, the constant functor is /not/ a monad: It fails the
monad identity laws for join. Similarly, ~f Œ± = Maybe (Œ±, Œ±)~ is an applicative
but /not/ a monad ---since there is no lawful definition of ~join~. Hence,
applicatives are strictly more generally than monads.
:Indeed:
#+BEGIN_SRC haskell
  id x = join $ fmap pure x
‚â° x = join $ mempty
‚â° x = mempty!
#+END_SRC
:End:

:Hide:
 #+BEGIN_SRC haskell
-- Either
join (Right (Right a)) = Right a
join (Right (Left e))  = Left e
join (Left e)          = Left e

 -- Cont
join f = \k -> f (\f' -> f' k)
 #+END_SRC
 :End:

* COMMENT Hide - monad laws

#+BEGIN_SRC haskell
-- join . pure = id
do {pure p} = p  -- ??

-- join . fmap pure = id
do {x <- p; pure x} = p -- cf RightIdentity!

-- join . fmap join = join . join
do {x ‚Üê p; do {C; r}} = do {x ‚Üê p; C; r} --?? cf Associtivity
#+END_SRC

* COMMENT Comparing Monad and Applicative

[[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][Intuitively]], the ~(>>=) :: m Œ± ‚Üí (Œ± ‚Üí m Œ≤) ‚Üí m Œ≤~ of a monad ~m~ allows the value
returned by one computation to influence the choice of another, whereas ~(<*>)~
keeps the structure of a computation fixed, just sequencing the effects. For
example, in ~wx >>= Œª x ‚Üí if x then wy else wz~ the value of ~wx~ will choose between
the /computations/ ~wy~ and ~wz~, performing only one, whilst ~(Œª x y z ‚Üí if x then y
else z) <$> wx <*> wy <*> wz~ performs the effects of all three computations,
using the value of ~wx~ to choose only between the /values/ of ~wy~ and ~wz~. For
example, if ~f Œ± = m Œ± = [Œ±]~ and ~wx = [True], wz = []~ then the applicative
expression is ~[]~ since the ‚Äòelse‚Äô computation ‚Äòfails‚Äô, whereas the monadic
expression is ~wy~. [[http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf][However]], whereas monads abort on the first ‚Äòfailure‚Äô, /with the
applicative interface we can continue in the face of errors./
#+BEGIN_SRC haskell
f :: Applicative f => f Bool -> f b -> f b -> f b
f xs ys zs = (\x y z -> if x then y else z) <$> xs <*> ys <*> zs

> f [True] [1..10] []
[]

m xs ys zs = xs >>= \x -> if x then ys else zs

> m [True] [1..10] []
[1,2,3,4,5,6,7,8,9,10]
#+END_SRC

Hence, properties of applicatives ---such as length--- can be determined
statically just by looking at the inputs, whereas monadic expressions can change
the collection structure ---and its properties--- since they can look at
intermediate results to decide what to do next.

Applicatives sequence independent effects, whereas monads allow effects to
depend on each other.

* COMMENT Examples
Then,



#
The Functor instance is straightforward for Sum, but the applicative instance is
puzzling. What should "pure" do? It needs to inject into either the left or the
right, so clearly we need some form of "bias" in the instance. What we really
need is the capacity to "work in" one side of the sum until compelled to switch
over to the other, at which point we're stuck there. If two functors, F and G
are in a relationship such that we can always send f x -> g x in a way that
"respects" fmap (that is to say, such that (fmap f . fToG == ftoG . fmap f) then
we call this a natural transformation. The action that sends f to g is typically
called "eta". (We actually want something slightly stronger called a "monoidal
natural transformation" that respects not only the functorial action fmap but
the applicative action <*>, but we can ignore that for now).
#
It turns out that a version of "Sum" with the initial transformation baked in now lives in transformers as Lift.
#
For ~Sum~, apply a function in ~f‚ÇÅ (a ‚Üí b) + f‚ÇÇ (a ‚Üí b)~ to the same tagged element
in ~f‚ÇÅ a + f‚ÇÇ a~ provided we have a /coherent/ translation ~Œ∑ : f‚ÇÅ Œ± ‚Üí f‚ÇÇ Œ±~. E.g.,
~Maybe Œ± ‚âÖ Identity Œ± + Const ()~ with ~Œ∑ = const ()~.
#+BEGIN_SRC haskell
ef <$> ea = ((Œª f ‚Üí (f +++ (ap f . Œ∑)) ea) ||| (Œª g ‚Üí (ap(g . Œ∑) +++ g) ea)) ef
ap = (<*>)
#+END_SRC
# Axioms of monoidal natural transformations
# Axiom 0:  fmap f . Œ∑ = Œ∑ . fmap f    -- naturality, free by parametericity
# Axiom 1:  Œ∑ . pure = pure            -- preserves pure
# Axiom 3:  Œ∑ (f <$> x) = Œ∑ f <$> Œ∑ x  -- homomorphism

+ ~Maybe~ for possibly failing computations.

Maybe. If we view 'no value' as analogous to null, then this bind function is
null propogation.

* Running Example ---A Simple Arithmetic Language

Let's start with a weak language:
#+BEGIN_SRC haskell :tangle simple_terms.hs
data Term = Int Int | Div Term Term deriving Show

thirteen = Int 1729 `Div` (Int 133 `Div` Int 1)
boom     = Int 1729 `Div` (Int 12  `Div` Int 0)

eval‚ÇÄ :: Term -> Int
eval‚ÇÄ (Int n) =  n
eval‚ÇÄ (n `Div` d) = let top    = eval‚ÇÄ n
                        bottom = eval‚ÇÄ d
                    in  top `div` bottom
#+END_SRC

How do we accomodate safe division by zero? Print to the user what's happening
at each step of the calcuation? Have terms that access ‚Äòglobal‚Äô variables? Have
terms that can store named expressions then access them later?

We'll make such languages and their ~eval~'s will be nearly just as simple as this
one (!) but accomodate these other issues.

* [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Maybe.html][Maybe]] ---Possibly Failing Computations
Safe evaluator: No division errors.
#+BEGIN_SRC haskell :tangle simple_terms.hs
eval‚ÇÅ :: Term -> Maybe Int
eval‚ÇÅ (Int n) = pure n
eval‚ÇÅ (n `Div` d) = do t <- eval‚ÇÅ n
                       b <- eval‚ÇÅ d
                       if b == 0 then Nothing else pure (t `div` b)
#+END_SRC
Exercise: Rewrite ~eval·µ¢~ without ~do~-notation and you'll end-up with nested case
analysis leading into a straicase of code that runs right off the page.

- Applicative is enough for ~eval‚ÇÅ, eval‚ÇÇ, eval‚ÇÉ~, but ~eval‚ÇÑ~ needs ~Monad~.

* [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Writer-Lazy.html#g:2][Writer]] ---Logging Information as we Compute

Use a pair type ~W Œµ Œ±~ to keep track of an environment ~Œµ~ and a value ~Œ±~.
#+BEGIN_SRC haskell :tangle simple_terms.hs
data Writer Œµ Œ± = W Œµ Œ± deriving Show

write :: Œµ -> Writer Œµ ()
write e = W e ()

instance Functor (Writer Œµ) where
  fmap f (W e a) = W e (f a)
#+END_SRC
Aggregate, merge, environments using their monoidal operation.
#+BEGIN_SRC haskell :tangle simple_terms.hs
instance Monoid Œµ => Applicative (Writer Œµ) where
  pure a = W mempty a
  (W e f) <*> (W d a) = W (e <> d) (f a)

instance Monoid Œµ => Monad (Writer Œµ) where
  (>>=) = \ ma f -> join (pure f <*> ma)
    where join (W e (W d a)) = W (e <> d) a
#+END_SRC

An evaluator that prints to the user what's going on.
#+BEGIN_SRC haskell :tangle simple_terms.hs
eval‚ÇÇ :: Term -> Writer String Int
eval‚ÇÇ it@(Int n) = W ("\n Evaluating: " ++ show it) n
eval‚ÇÇ it@(n `Div` d) = do write $ "\n Evaluating: " ++ show it
                          t <- eval‚ÇÇ n
                          b <- eval‚ÇÇ d
                          pure $ (t `div` b)

-- Try this! With ‚Äúboom‚Äù, we get to see up to the boint of the error ^_^
-- let W e x = eval‚ÇÇ thirteen in putStrLn e
#+END_SRC

* spacing break                                                      :ignore:
#+latex: \vspace{-1em}
* [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2][Reader]] ---Accessing ‚ÄòGlobal, read-only, data‚Äô
# Reader let's us simulate ‚Äúglobal, read-only, data‚Äù.

#+latex: \hspace{-1.5em}
Use a function type ~Œµ ‚Üí Œ±~ to get ~Œ±~-values that ‚Äòreads‚Äô from a configuration
environment Œµ.
#+BEGIN_SRC haskell :tangle terms_with_vars.hs
data Reader Œµ Œ± = R {run :: Œµ -> Œ±}

instance Functor (Reader Œµ) where
  fmap f (R g) = R $ f . g

instance Applicative (Reader Œµ) where
  pure a = R $ const a
  (R f) <*> (R g) = R $ \e -> f e (g e) {- ‚ÄúS‚Äù combinator -}

instance Monad (Reader Œµ) where
  ma >>= f = join (pure f <*> ma)
    where join (R rf) = R $ \e -> run (rf e) e
#+END_SRC

A language with access to global variables; uninitialised variables are 0 by
default.
#+BEGIN_SRC haskell :tangle terms_with_vars.hs
data Term = Int Int | Div Term Term | Var String deriving Show

type GlobalVars = [(String, Int)]

valuefrom :: String -> GlobalVars -> Int
valuefrom x gvs = maybe 0 id $ lookup x gvs

eval‚ÇÉ :: Term -> Reader GlobalVars Int
eval‚ÇÉ (Int x) = pure x
eval‚ÇÉ (Var x) = R $ \e -> x `valuefrom` e
eval‚ÇÉ (n `Div` d) = do t <- eval‚ÇÉ n
                       b <- eval‚ÇÉ d
                       pure (t `div` b)

state    = [("x", 1729), ("y", 133)] :: GlobalVars
thirteen = Var "x" `Div` (Var "y" `Div` Int 1)
-- run (eval‚ÇÉ thirteen) state
#+END_SRC

* [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2][State]] ---Read and write to local storage

Let's combine writer and reader to get state: We can both read and write to data
by using functions ~Œµ ‚Üí (Œµ, Œ±)~ that read from an environment Œµ and result in a
new environment as well as a value.
- ~IO Œ± ‚âÖ State TheRealWorld Œ±~ ;-)
#+BEGIN_SRC haskell :tangle terms_with_storage.hs
data State Œµ Œ± = S {run :: Œµ -> (Œµ, Œ±)}

push :: Monoid Œµ => Œµ -> State Œµ ()
push d = S $ \e -> (d <> e, ())

instance Functor (State Œµ) where
  fmap f (S g) = S $ \ e -> let (e', a) = g e in (e', f a)

instance Applicative (State Œµ) where
  pure a = S $ \e -> (e, a)
  (S sf) <*> (S g) = S $ \e -> let (e',  a) = g e
                                   (e'', f) = sf e' in (e'', f a)

instance Monad (State Œµ) where
  ma >>= f = join (pure f <*> ma)
    where join (S sf) = S $ \e -> let (e', S f) = sf e in f e'
#+END_SRC

A simple language with storage; a program's value is the value of its final store.
:Repeated:
#+BEGIN_SRC haskell :tangle terms_with_storage.hs
type GlobalVars = [(String, Int)]

valuefrom :: String -> GlobalVars -> Int
valuefrom x gvs = maybe 0 id $ lookup x gvs
#+END_SRC
:End:

#+BEGIN_SRC haskell :tangle terms_with_storage.hs
data Expr = Let String Expr Expr | Var String | Int Int | Div Expr Expr
           deriving Show

eval‚ÇÑ :: Expr -> State GlobalVars Int
eval‚ÇÑ (Var x) = S $ \e -> let r = x `valuefrom` e in ((x,r):e, r)
eval‚ÇÑ (Int x) = pure x
eval‚ÇÑ (Let x t body) = do n <- eval‚ÇÑ t
                          push [(x, n)] -- Applicative is NOT enough here!
                          eval‚ÇÑ body
eval‚ÇÑ (n `Div` d) = do t <- eval‚ÇÑ n; b <- eval‚ÇÑ d; pure (t `div` b)

thirteen = Let "x" (Int 1729)
             $ Let "y" (Int 133 `Div` Int 1)
                $ Var "x" `Div` Var "y"

-- run (eval‚ÇÑ thirteen) []
#+END_SRC

Exercise: Add to the oringal =Term= type a constructor =Rndm [Term]=, where =Rndm
[t‚ÇÅ, ‚Ä¶, t‚Çô]= denotes non-deterministicly choosing one of the terms ~t·µ¢~. Then write
an evaluator that considers all possible branches of a computation:
~eval‚ÇÖ : Term ‚Üí [Int]~.

If we want to mixin any of the features for our evaluators, we need to use ‚Äòmonad
transformers‚Äô since monads do not compose in general.

* spacing break                                                      :ignore:
#+latex: \columnbreak
* Reads

+ /Introduction to Functional Programming/ by Richard Bird
  - Assuming no programming, this book end by showing how to write a theorem
    prover powerful enough to prove many of laws scattered throughout the book.

+ [[http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf][Monads for functional programming]] by Philip Wadler
  - This covers the ~eval·µ¢~ and more ^_^

+ [[https://docs.racket-lang.org/heresy/monad-do.html][Comprehending Monads]] by Philip Wadler

+ [[http://dev.stephendiehl.com/hask/][What I Wish I Knew When Learning Haskell]]

+ [[https://wiki.haskell.org/Typeclassopedia][Typeclassopedia]] ---/The essentials of each type class are introduced, with
   examples, commentary, and extensive references for further reading./

+ [[http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html][You Could Have Invented Monads! (And Maybe You Already Have.)]]

+ [[http://learnyouahaskell.com/chapters][Learn You a Haskell for Great Good]] ---An accessible read with many examples, and drawings

+ [[https://en.wikibooks.org/wiki/Haskell][The Haskell WikiBook]] ---Has four beginner's tracks and four advanced tracks

+ [[https://alhassy.github.io/CatsCheatSheet/CheatSheet.pdf][Category Theory Cheat Sheet]] ---The ‚Äútheory of typed composition‚Äù:
  Products, Sums, Functors, Natural Transformations ^_^

+ [[https://alhassy.github.io/AgdaCheatSheet/CheatSheet.pdf][Agda Cheat Sheet]] ---Agda is Haskell on steroids in that it you can invoke
  Haskell code and write proofs for it.

+ LINQ for [[http://tomasp.net/blog/idioms-in-linq.aspx/#csidiomsl][applicatives]] and [[https://livebook.manning.com/book/real-world-functional-programming/chapter-12/28][monads]].
  - Monads ‚âà SQL/Linq ‚âà Comprehensions/Generators

 :TODO:
 http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows-and-idioms
 How arrows fit into the functor/applicative/monad hierarchy? See Idioms are
 oblivious, arrows are meticulous, monads are promiscuous by Sam Lindley, Philip
 Wadler, Jeremy Yallop. MSFP 2008. (They call applicative functors idioms.) The
 abstract:

 We revisit the connection between three notions of computation: Moggi's monads,
 Hughes's arrows and McBride and Paterson's idioms (also called applicative
 functors). We show that idioms are equivalent to arrows that satisfy the type
 isomorphism A ~> B = 1 ~> (A -> B) and that monads are equivalent to arrows that
 satisfy the type isomorphism A ~> B = A -> (1 ~> B). Further, idioms embed into
 arrows and arrows embed into monads.
 :END:

* COMMENT What if I want ~N~ columns? Or non-landscape? Or multiple formats?

Press ~C-c C-c~ on the following incantation to produce a single column portrait of the cheat sheet.
#+name: make-portrait
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: CheatSheet_Portrait.pdf
     ,#+LATEX_HEADER_EXTRA: \\landscapefalse \\def\\cheatsheetcols{1}
     ,#+INCLUDE: CheatSheet.org
    ")

    (let ((org-export-use-babel nil))
      (org-mode)
      (org-latex-export-to-pdf)
      )
)
#+END_SRC

* COMMENT Basic Equational Support

# Basic name-formula equational support.

~\eqn{name}{formula}~
yields a displayed equation with ~formula~ left aligned and ~name~ right aligned:

#+latex: \vspace{-0.7em}
\eqn{name}{formula}
#+BEGIN_EXPORT latex
\eqn{Functoriality}{
  F(f_0 \circ \cdots \circ f_{n-1}) \;=\; F\, f_0 \circ \cdots \circ F\, f_{n-1}
  }
#+END_EXPORT

Moreover, we can refer to such a formula by invoking ~\ref{name}~ ---e.g., \ref{Functoriality} and \ref{name}.
However, if ~name~ involves unicode symbols, then this may cause problems.

See the [[https://github.com/alhassy/CatsCheatSheet][CatsCheatSheet]] for examples of this kind.

We may also use [[https://github.com/jkitchin/org-ref][org-ref]] style references, as in ~eqref:name~. However, org-ref may warn that
no context for the reference is found ---that's okay.

+ eqref   :: Parenthesised reference: eqref:name
+ autoref :: Prefix reference with type: autoref:name
+ nameref :: The name of the section that contains this reference: nameref:name

:MultipleEquationsExample:

preamble words here --below comes from CatsCheatSheet--

#+BEGIN_EXPORT latex
\begineqns

\eqn{$\langle\rangle$-Type}{f : C ‚Üí A \lands g : C ‚Üí B \impliesS ‚ü®f, g‚ü© : C ‚Üí A √ó B}

\eqn{$\langle\rangle$-Char}{ \fst ‚àò x = f \lands \snd ‚àò x = g \equivS x = ‚ü®f, g‚ü© }

\eqn{$\langle\rangle$-Cancellation; $\langle\rangle$-Self}{ \fst ‚àò ‚ü®f, g‚ü© = f \landS \snd ‚àò ‚ü®f, g‚ü© = g}

\eqn{$\langle\rangle$-Id}{ ‚ü®\fst, \snd‚ü© = \Id}

\eqn{$\langle\rangle$-Unique}{ \fst ‚àò x = \fst ‚àò y  \lands \snd ‚àò x = \snd ‚àò y \impliesS x = y}

\eqn{$\langle\rangle$-Fusion}{ ‚ü®f , g‚ü© ‚àò x = ‚ü®f ‚àò x , g ‚àò x‚ü© }

\eqn{$\langle\rangle$-Functor-Dist}{F \, ‚ü®f, g‚ü©_ùíû = ‚ü®F \, f , F \, g‚ü©_ùíü \qquad\text{ where } F : ùíû ‚Üí ùíü}

\endeqns
#+END_EXPORT

#+latex: \room
#+latex: \room

postamble words here

:End:

#+latex: \vspace{-3em}
* COMMENT Parallel Environment

Cheat sheets should not waste space, so the setup provides
a ~parallel~ LaTeX enviornment that takes an optional parameter
indicating how many columns are desired ---two by default.
Importantly, we use this environment as if it were any normal org-block:
#
#+begin_parallel org
#+BEGIN_EXAMPLE org :tangle no
,#‚∏≤
,#+begin_parallel org
???content here???
,#+end_parallel
#+END_EXAMPLE

The initial new line is important, otherwise the parallel environment
occurs in-line, which may not be the intended behaviour.
#+end_parallel

The column break is automatic, but as
this is sugar for a ~minipage~ containing a ~multicolum~ we can force a column
separation with ~\columnbreak~.
# This command, in Org, necessities newlines between
# the items being separated.

~parallelNB~ produces a side-by-side rendition with ‚ÄòN‚Äôo ‚ÄòB‚Äôar:
#
#+begin_parallelNB org
left \newline left \newline left

#+latex: \columnbreak
right \newline right \newline right
#+end_parallelNB

Here is an example with four columns:
#
#+ATTR_LATEX: :options [4]
#+begin_parallel org
left \newline left \newline left

#+latex: \columnbreak
middle \newline middle \newline middle

#+latex: \columnbreak
middle \newline middle \newline middle

#+latex: \columnbreak
right \newline right \newline right
#+end_parallel

Here is an example with three columns and ‚Äòn‚Äôo ‚Äòb‚Äôar:
#
#+begin_parallel3NB org
left \newline left \newline left

#+latex: \columnbreak
middle \newline middle \newline middle

#+latex: \columnbreak
right \newline right \newline right
#+end_parallel3NB

#+latex: \vfill {\color{white}.}

* spacing COMMENT break :accomodating_multiple_formats:ignore:

#+LATEX: \ifnum\cheatsheetcols=1 \newpage \else \columnbreak \fi

* COMMENT Making ~README.org~

  Evaluate the following source block with ~C-c C-c~
  to produce a ~README~ file.

  # :'( For some reason using {{{title}}} below would not work.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org
     # HTML: <h1> HaskellCheatSheet </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

     :Hide:
     This project is to contain a listing of common results in X Theory.

     ,*The repo contains other articles I've written on X Theory;*
     ,*which may be read in a blog-format at:*
     https://alhassy.github.io/blog/categories/#Xtheory
     :End:

     #+begin_quote
    ,*The listing sheet, as PDF, can be found
     [[https://alhassy.github.io/HaskellCheatSheet/CheatSheet.pdf][here]]*,
     or as a [[https://alhassy.github.io/HaskellCheatSheet/CheatSheet_Portrait.pdf][single column portrait]],
     while below is an unruly html rendition.
     #+end_quote

     # Markdown links: [title](target)

     This reference sheet is built from a
     [[https://github.com/alhassy/CheatSheet][CheatSheets with Org-mode]]
     system.

     #+html: <p align=\"center\"><a href=\"https://www.haskell.org/\"><img src=\"https://img.shields.io/badge/GHC-8.6.4-b48ead.svg?style=plastic\"/></a>

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      ; (org-md-export-to-markdown)
      ; (package-install 'toc-org)
      (toc-org-mode)
      (toc-org-insert-toc)
      (org-org-export-to-org)
      )
)
#+END_SRC


Note that the ~blurb~ macro is defined by the user, to provide a terse description of the project.
   - Think the one-line statement at the top of a github repo page.

#    The ~d:nil~ ensures the ‚Äòdrawer‚Äô ~:Hide: ‚ãØ :End:~ is not exported; it's there for me
#    as a reminder.
